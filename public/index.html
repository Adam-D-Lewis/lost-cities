<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lost Cities - Local Network Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px; /* Reduced padding */
    }
    h1 {
      color: #2c3e50;
      text-align: center;
    }
    .game-status {
      text-align: center;
      font-size: 1em; /* Reduced font size */
      margin-bottom: 10px; /* Reduced margin */
      padding: 8px; /* Reduced padding */
      background-color: #e2e2e2;
      border-radius: 5px;
    }
    .scores {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px; /* Reduced margin */
    }
    .score-card {
      background-color: white;
      padding: 8px 15px; /* Reduced padding */
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      min-width: 120px; /* Reduced min-width */
      text-align: center;
    }
    .score-card.active {
      border: 2px solid #3498db;
    }
    .board {
      display: flex; /* To arrange columns and deck area side-by-side */
      justify-content: space-between;
      gap: 10px; /* Reduced gap */
      margin-bottom: 10px; /* Reduced margin */
    }
    /* .play-area styles removed */
    /* .expedition-area styles removed (or will be implicitly covered by .color-column structure) */
    .hand {
      background-color: #3498db;
      padding: 10px; /* Reduced padding */
      border-radius: 10px;
      display: flex;
      justify-content: center;
      gap: 5px; /* Reduced gap */
    }
    .card {
      width: 50px; /* Reduced width */
      height: 75px; /* Reduced height */
      background-color: white;
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Align content to the top */
      padding-top: 3px; /* Add some space at the top of the card */
      align-items: center;
      font-weight: bold;
      font-size: 1em; /* Reduced font size */
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Reduced shadow */
      border: 1px solid #333; /* Added border for better contrast */
      position: relative;
      transition: transform 0.2s;
    }
    .card:hover {
      transform: translateY(-5px);
    }
    .card.red { color: #e74c3c; }
    .card.green { color: #2ecc71; }
    .card.blue { color: #3498db; }
    .card.white { color: #95a5a6; }
    .card.yellow { color: #f1c40f; }
    .card.back {
      background-color: #34495e;
      color: white;
    }
    .expedition {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px; /* Reduced gap */
    }
    .expedition-cards {
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Ensure cards stack from the top */
      height: 350px; /* Max height: 1st card (75px) + 11 more cards (11 * 25px = 275px) = 350px */
      /* gap: 2px; /* Removed gap for overlapping */
    }
    /* .discard-piles (container) styles removed */
    .controls {
      display: flex;
      justify-content: center;
      gap: 10px; /* Reduced gap */
      margin-bottom: 10px; /* Reduced margin */
    }
    .btn {
      padding: 8px 15px; /* Reduced padding */
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px; /* Reduced font size */
    }
    .btn:hover {
      background-color: #2980b9;
    }
    .btn:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    .setup-screen {
      max-width: 500px;
      margin: 20px auto; /* Reduced margin */
      padding: 20px; /* Reduced padding */
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      text-align: center;
    }
    .input-group {
      margin-bottom: 15px; /* Reduced margin */
    }
    input {
      padding: 8px; /* Reduced padding */
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px; /* Reduced font size */
      margin-top: 5px;
    }
    /* .color-indicator styles removed */
    .expedition-label {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .deck {
      position: relative; /* No longer absolute */
      width: 60px; 
      height: 85px; 
      text-align: center;
    }
    .deck-count {
      /* position: absolute; bottom: -15px; */ /* Re-evaluate if needed, for now simpler */
      width: 100%;
      text-align: center;
      font-weight: bold;
      margin-top: 5px; /* Add some space if not absolutely positioned */
    }
    /* .opponent-area, .player-area styles removed */
    /* .area-label styles removed (labels will be per expedition/discard pile) */

    /* New styles for column layout */
    #game-columns-container {
      display: flex;
      flex-grow: 1; /* Takes up available space */
      justify-content: space-around; /* Distributes columns */
      gap: 10px; /* Space between color columns */
    }
    .color-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px; /* Space between opponent exp, discard, player exp */
      padding: 10px;
      /* background-color will be set dynamically by JS */
      border-radius: 8px;
      min-width: 80px; /* Ensure columns have some base width */
    }
    .deck-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* Center deck vertically */
      padding: 10px;
      min-width: 80px; /* Give deck area some width */
    }
    .card-value {
      font-size: 18px; /* Reduced font size */
      font-weight: bold;
    }
    .card-suit {
      font-size: 10px; /* Reduced font size */
      margin-top: 3px; /* Reduced margin */
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #2c3e50;
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .notification.show {
      opacity: 1;
    }
    .history-log {
      height: 80px; /* Reduced height */
      overflow-y: auto;
      background-color: white;
      padding: 8px; /* Reduced padding */
      border-radius: 5px;
      margin-bottom: 10px; /* Reduced margin */
      font-size: 12px; /* Reduced font size */
    }
    .history-log p {
      margin: 3px 0; /* Reduced margin */
    }
    .server-info {
      text-align: center;
      margin-top: 10px; /* Reduced margin */
      padding: 8px; /* Reduced padding */
      background-color: #f8f9fa;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="setup-screen" class="setup-screen">
    <h1>Lost Cities</h1>
    <p>Play Lost Cities with your partner on your local network</p>
    
    <div class="input-group">
      <label for="playerName">Your Name:</label>
      <input type="text" id="playerName" placeholder="Enter your name">
    </div>
    
    <div class="input-group">
      <label for="serverAddress">Server Address:</label>
      <input type="text" id="serverAddress" placeholder="Enter server address (e.g., http://192.168.1.100:3000)">
      <p id="local-ip"></p>
    </div>
    
    <div class="input-group">
      <button id="createGame" class="btn">Create Game</button>
      <button id="joinGame" class="btn">Join Game</button>
    </div>
  </div>

  <div id="game-container" class="container" style="display: none;">
    <h1>Lost Cities</h1>
    <div id="game-status" class="game-status">Waiting for opponent...</div>
    
    <div class="scores">
      <div id="player-score" class="score-card">
        <h3 id="player-name">You: 0</h3>
        <p>Score: <span id="player-score-value">0</span></p>
      </div>
      <div id="opponent-score" class="score-card">
        <h3 id="opponent-name">Opponent: 0</h3>
        <p>Score: <span id="opponent-score-value">0</span></p>
      </div>
    </div>

    <div class="history-log" id="history-log">
      <p>Game started. Waiting for players...</p>
    </div>
    
    <div class="board">
      <div id="game-columns-container">
        <!-- Color columns will be dynamically generated here by JavaScript -->
      </div>
      <div class="deck-area">
        <div class="deck" id="deck">
          <div class="card back">
            <div class="card-value">LC</div>
          </div>
          <div class="deck-count" id="deck-count">60</div>
        </div>
      </div>
    </div>
      
    <div class="hand" id="player-hand">
        <!-- Player's hand will be rendered here -->
      </div>
    </div>
    
    <div class="controls">
      <button id="play-card" class="btn" disabled>Play Card</button>
      <button id="discard-card" class="btn" disabled>Discard Card</button>
      <button id="draw-deck" class="btn" disabled>Draw from Deck</button>
      <button id="draw-discard" class="btn" disabled>Draw from Discard</button>
    </div>

    <div class="server-info" id="server-info"></div>
  </div>

  <div id="notification" class="notification"></div>

  <script>
    // Game state
    let gameState = {
      gameId: null, // Added to store gameId locally
      playerId: null, // This will store the persistentPlayerId
      playerName: '',
      opponentName: '',
      currentTurn: null, // This will be a persistentPlayerId
      selectedCard: null,
      selectedTarget: null,
      gamePhase: 'waiting', // waiting, selectCard, selectTarget, drawCard, gameOver
      hand: [],
      playerExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      opponentExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      discardPiles: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      deckCount: 60,
      playerScore: 0,
      opponentScore: 0
    };

    // Socket connection
    let socket;
    let audioContext; // For playing sounds
    
    // DOM Elements
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const gameStatus = document.getElementById('game-status');
    const playerNameInput = document.getElementById('playerName');
    const serverAddressInput = document.getElementById('serverAddress');
    const createGameBtn = document.getElementById('createGame');
    const joinGameBtn = document.getElementById('joinGame');
    const playerHandEl = document.getElementById('player-hand');
    // const playerExpeditionsEl = document.getElementById('player-expeditions'); // Removed
    // const opponentExpeditionsEl = document.getElementById('opponent-expeditions'); // Removed
    // const discardPilesEl = document.getElementById('discard-piles'); // Removed
    const deckEl = document.getElementById('deck');
    const deckCountEl = document.getElementById('deck-count');
    const playCardBtn = document.getElementById('play-card');
    const discardCardBtn = document.getElementById('discard-card');
    const drawDeckBtn = document.getElementById('draw-deck');
    const drawDiscardBtn = document.getElementById('draw-discard');
    const playerScoreEl = document.getElementById('player-score-value');
    const opponentScoreEl = document.getElementById('opponent-score-value');
    const playerNameEl = document.getElementById('player-name');
    const opponentNameEl = document.getElementById('opponent-name');
    const notificationEl = document.getElementById('notification');
    const historyLogEl = document.getElementById('history-log');
    const localIpEl = document.getElementById('local-ip');
    const serverInfoEl = document.getElementById('server-info');

    // Get local IP address to help setup
    // This function remains the same, but its call is moved to after DOM content loaded.

    // Show notification
    function showNotification(message) {
      notificationEl.textContent = message;
      notificationEl.classList.add('show');
      setTimeout(() => {
        notificationEl.classList.remove('show');
      }, 3000);
    }

    // Add message to history log
    function addToHistory(message) {
      const p = document.createElement('p');
      p.textContent = message;
      historyLogEl.appendChild(p);
      historyLogEl.scrollTop = historyLogEl.scrollHeight;
    }

    // Initialize the game UI
    function initializeGame() {
      setupScreen.style.display = 'none';
      gameContainer.style.display = 'block';
      
      createBoardLayout(); // New function to create the column-based layout
    }

    // initializeExpeditionAreas function removed
    // initializeDiscardPiles function removed

    // Render the game state
    function createBoardLayout() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      const gameColumnsContainer = document.getElementById('game-columns-container');
      gameColumnsContainer.innerHTML = ''; // Clear previous layout

      colors.forEach(color => {
        const columnEl = document.createElement('div');
        columnEl.className = 'color-column';
        columnEl.style.backgroundColor = getPastelColorCode(color); // Set column background

        // 1. Opponent's Expedition Area
        const opponentExpeditionContainer = document.createElement('div');
        opponentExpeditionContainer.className = 'expedition'; 
        
        const opponentLabel = document.createElement('div');
        opponentLabel.className = 'expedition-label';
        // const opponentColorIndicator = document.createElement('span'); // Removed
        // opponentColorIndicator.className = 'color-indicator'; // Removed
        // opponentColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // opponentLabel.appendChild(opponentColorIndicator); // Removed
        opponentLabel.appendChild(document.createTextNode(`Opponent ${capitalizeFirstLetter(color)}`)); 
        
        const opponentCardsEl = document.createElement('div');
        opponentCardsEl.className = 'expedition-cards';
        opponentCardsEl.id = `opponent-${color}-expedition`;
        
        opponentExpeditionContainer.appendChild(opponentLabel);
        opponentExpeditionContainer.appendChild(opponentCardsEl);
        columnEl.appendChild(opponentExpeditionContainer);

        // 2. Discard Pile Area
        const discardPileContainer = document.createElement('div');
        discardPileContainer.className = 'expedition'; 

        const discardLabel = document.createElement('div');
        discardLabel.className = 'expedition-label';
        // For discard, use the color indicator as well for consistency // Removed
        // const discardColorIndicator = document.createElement('span'); // Removed
        // discardColorIndicator.className = 'color-indicator'; // Removed
        // discardColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // discardLabel.appendChild(discardColorIndicator); // Removed
        discardLabel.appendChild(document.createTextNode(`Discard`));
        
        const discardCardEl = document.createElement('div');
        discardCardEl.className = 'card'; 
        discardCardEl.classList.add(color); 
        discardCardEl.id = `discard-${color}`;
        discardCardEl.dataset.color = color;
        discardCardEl.innerHTML = '<div class="card-value">-</div>'; 
        discardCardEl.addEventListener('click', () => selectDiscardTarget(color));

        discardPileContainer.appendChild(discardLabel);
        discardPileContainer.appendChild(discardCardEl);
        columnEl.appendChild(discardPileContainer);

        // 3. Player's Expedition Area
        const playerExpeditionContainer = document.createElement('div');
        playerExpeditionContainer.className = 'expedition'; 
        
        const playerLabel = document.createElement('div');
        playerLabel.className = 'expedition-label';
        // const playerColorIndicator = document.createElement('span'); // Removed
        // playerColorIndicator.className = 'color-indicator'; // Removed
        // playerColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // playerLabel.appendChild(playerColorIndicator); // Removed
        playerLabel.appendChild(document.createTextNode(`Your ${capitalizeFirstLetter(color)}`));

        const playerCardsEl = document.createElement('div');
        playerCardsEl.className = 'expedition-cards';
        playerCardsEl.id = `player-${color}-expedition`;
        playerCardsEl.dataset.color = color;
        playerCardsEl.addEventListener('click', () => selectExpeditionTarget(color));

        playerExpeditionContainer.appendChild(playerLabel);
        playerExpeditionContainer.appendChild(playerCardsEl);
        columnEl.appendChild(playerExpeditionContainer);

        gameColumnsContainer.appendChild(columnEl);
      });
      
      // Ensure deck click listener is active (it should be fine as deckEl is static HTML)
      // If deckEl was dynamically created, you'd add listener here.
      // deckEl.addEventListener('click', () => drawFromDeck()); // Already added globally
    }

    function renderGameState() {
      renderHand();
      renderExpeditions();
      renderDiscardPiles();
      updateDeckCount();
      updateScores();
      updateGameStatus();
      updateControls();
    }

    function renderHand() {
      playerHandEl.innerHTML = '';
      
      gameState.hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card';
        cardEl.classList.add(card.color);
        cardEl.dataset.index = index;
        cardEl.dataset.color = card.color;
        cardEl.dataset.value = card.value;
        
        const valueEl = document.createElement('div');
        valueEl.className = 'card-value';
        valueEl.textContent = card.value === 0 ? '★' : card.value;
        
        const suitEl = document.createElement('div');
        suitEl.className = 'card-suit';
        suitEl.textContent = capitalizeFirstLetter(card.color);
        
        cardEl.appendChild(valueEl);
        cardEl.appendChild(suitEl);
        
        if (gameState.selectedCard === index) {
          cardEl.style.border = '3px solid black';
        }
        
        cardEl.addEventListener('click', () => selectCard(index));
        playerHandEl.appendChild(cardEl);
      });
    }

    function renderExpeditions() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const playerExpEl = document.getElementById(`player-${color}-expedition`);
        const opponentExpEl = document.getElementById(`opponent-${color}-expedition`);
        
        // Clear existing cards
        playerExpEl.innerHTML = '';
        opponentExpEl.innerHTML = '';
        
        // Render player expedition
        gameState.playerExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          cardEl.classList.add(color);
          
          const valueEl = document.createElement('div');
          valueEl.className = 'card-value';
          valueEl.textContent = card.value === 0 ? '★' : card.value;
          
          cardEl.appendChild(valueEl);
          
          if (playerExpEl.childNodes.length > 0) { // Apply negative margin to subsequent cards
            cardEl.style.marginTop = '-50px'; // 75px card height - 25px visible top = 50px overlap
          }
          playerExpEl.appendChild(cardEl);
        });
        
        // Render opponent expedition
        gameState.opponentExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          cardEl.classList.add(color);
          
          const valueEl = document.createElement('div');
          valueEl.className = 'card-value';
          valueEl.textContent = card.value === 0 ? '★' : card.value;
          
          cardEl.appendChild(valueEl);

          if (opponentExpEl.childNodes.length > 0) { // Apply negative margin to subsequent cards
            cardEl.style.marginTop = '-50px';
          }
          opponentExpEl.appendChild(cardEl);
        });
        
        // Add highlight if selected as target
        if (gameState.selectedTarget === `expedition-${color}`) {
          playerExpEl.style.border = '3px solid black';
        } else {
          playerExpEl.style.border = 'none';
        }
      });
    }

    function renderDiscardPiles() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const discardEl = document.getElementById(`discard-${color}`);
        const discardPile = gameState.discardPiles[color];
        
        if (discardPile.length > 0) {
          const topCard = discardPile[discardPile.length - 1];
          discardEl.innerHTML = `<div class="card-value">${topCard.value === 0 ? '★' : topCard.value}</div>`;
        } else {
          discardEl.innerHTML = '<div class="card-value">-</div>';
        }
        
        // Add highlight if selected as target
        if (gameState.selectedTarget === `discard-${color}`) {
          discardEl.style.border = '3px solid black';
        } else {
          discardEl.style.border = 'none';
        }
      });
    }

    function updateDeckCount() {
      deckCountEl.textContent = gameState.deckCount;
    }

    function updateScores() {
      playerScoreEl.textContent = gameState.playerScore;
      opponentScoreEl.textContent = gameState.opponentScore;
      
      playerNameEl.textContent = `${gameState.playerName}: ${gameState.playerScore}`;
      opponentNameEl.textContent = `${gameState.opponentName}: ${gameState.opponentScore}`;
    }

    function updateGameStatus() {
      const playerScoreCard = document.getElementById('player-score');
      const opponentScoreCard = document.getElementById('opponent-score');
      
      playerScoreCard.classList.remove('active');
      opponentScoreCard.classList.remove('active');
      
      if (gameState.gamePhase === 'waiting') {
        gameStatus.textContent = 'Waiting for opponent...';
      } else if (gameState.gamePhase === 'gameOver') {
        gameStatus.textContent = 'Game Over!';
      } else if (gameState.currentTurn === gameState.playerId) {
        playerScoreCard.classList.add('active');
        
        if (gameState.gamePhase === 'selectCard') {
          if (gameState.selectedCard !== null) {
            if (gameState.selectedTarget && gameState.selectedTarget.startsWith('discard')) {
              gameStatus.textContent = 'Card and discard pile selected. Click "Discard Card".';
            } else {
              // If an expedition is selected, it's just for visual feedback or drawing, not for playing.
              gameStatus.textContent = 'Card selected. Click "Play Card" (plays to its color) or "Discard Card".';
            }
          } else {
            gameStatus.textContent = 'Your turn: Select a card to play or discard';
          }
        } else if (gameState.gamePhase === 'drawCard') {
          gameStatus.textContent = 'Draw a card from the deck or a discard pile';
        }
      } else {
        opponentScoreCard.classList.add('active');
        gameStatus.textContent = `${gameState.opponentName}'s turn`;
      }
    }

    function updateControls() {
      const isPlayerTurn = gameState.currentTurn === gameState.playerId;
      const cardSelected = gameState.selectedCard !== null;
      const targetSelected = gameState.selectedTarget !== null;
      const isSelectCardPhase = gameState.gamePhase === 'selectCard';
      const isDrawCardPhase = gameState.gamePhase === 'drawCard';
      
      playCardBtn.disabled = !(isPlayerTurn && cardSelected && isSelectCardPhase);
      // For discardCardBtn: enabled if it's player's turn, card selected, in selectCard phase, AND
      // (no target is selected OR a discard pile is selected)
      let canDiscard = false;
      if (isPlayerTurn && cardSelected && isSelectCardPhase) {
        // Ensure selectedTarget is a string before calling startsWith if targetSelected is true
        if (!targetSelected || (targetSelected && typeof gameState.selectedTarget === 'string' && gameState.selectedTarget.startsWith('discard'))) {
          canDiscard = true;
        }
      }
      discardCardBtn.disabled = !canDiscard;
      
      drawDeckBtn.disabled = !(isPlayerTurn && isDrawCardPhase);
      
      let canDrawFromDiscard = false;
      // Check player turn and phase first, then if a target is selected, then if it's a discard pile.
      if (isPlayerTurn && isDrawCardPhase && targetSelected && typeof gameState.selectedTarget === 'string' && gameState.selectedTarget.startsWith('discard')) {
        canDrawFromDiscard = true;
      }
      // For debugging, you might uncomment this log:
      console.log(`DEBUG: updateControls - DrawDiscard: isPlayerTurn=${isPlayerTurn}, isDrawCardPhase=${isDrawCardPhase}, targetSelected=${targetSelected}, selectedTarget="${gameState.selectedTarget}", typeof selectedTarget="${typeof gameState.selectedTarget}", canDrawFromDiscard=${canDrawFromDiscard}`);
      drawDiscardBtn.disabled = !canDrawFromDiscard;
    }

    // Game actions
    function selectCard(index) {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'selectCard') {
        return;
      }
      
      if (gameState.selectedCard === index) {
        gameState.selectedCard = null;
      } else {
        gameState.selectedCard = index;
      }
      
      renderGameState();
    }

    function selectExpeditionTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      if (gameState.selectedTarget === `expedition-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `expedition-${color}`;
      }
      
      renderGameState();
    }

    function selectDiscardTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      // Can't draw from empty discard pile
      if (gameState.gamePhase === 'drawCard' && gameState.discardPiles[color].length === 0) {
        showNotification("Can't draw from an empty discard pile");
        console.log(`DEBUG: selectDiscardTarget - Attempted to select empty discard pile: ${color}`);
        return;
      }
      
      console.log(`DEBUG: selectDiscardTarget - Color: ${color}, Current Phase: ${gameState.gamePhase}, Pile content:`, JSON.stringify(gameState.discardPiles[color]));
      if (gameState.selectedTarget === `discard-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `discard-${color}`;
      }
      
      renderGameState();
    }

    function playCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      const targetColor = card.color; // Play to the card's own color expedition
      
      // Check if card can be played on this expedition (this check might seem redundant now, but good for safety)
      if (card.color !== targetColor) {
        showNotification(`Can only play ${card.color} cards on the ${card.color} expedition`);
        return;
      }
      
      // Check if card value is valid (must be ascending)
      const expedition = gameState.playerExpeditions[targetColor];
      if (expedition.length > 0) {
        const lastCardValue = expedition[expedition.length - 1].value;
        if (card.value <= lastCardValue && lastCardValue !== 0) {
          showNotification(`Card value must be higher than the last card (${lastCardValue})`);
          return;
        }
      }
      
      // Send play card action to server
      socket.emit('playCard', {
        cardIndex: gameState.selectedCard,
        target: targetColor
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function discardCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      let targetColor = card.color;
      
      // If a specific discard pile was selected, use that instead
      if (gameState.selectedTarget && gameState.selectedTarget.startsWith('discard')) {
        targetColor = gameState.selectedTarget.split('-')[1];
      }
      
      // Send discard card action to server
      socket.emit('discardCard', {
        cardIndex: gameState.selectedCard,
        color: targetColor
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function drawFromDeck() {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'drawCard') {
        return;
      }
      
      // Send draw from deck action to server
      socket.emit('drawCard', { source: 'deck' });
      
      // Reset selection
      gameState.selectedTarget = null;
    }

    function drawFromDiscard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'drawCard' ||
          !gameState.selectedTarget ||
          !gameState.selectedTarget.startsWith('discard')) {
        return;
      }
      
      const color = gameState.selectedTarget.split('-')[1];
      
      // Check if discard pile has cards
      if (gameState.discardPiles[color].length === 0) {
        showNotification(`Discard pile is empty`);
        return;
      }
      
      // Send draw from discard action to server
      socket.emit('drawCard', { source: 'discard', color: color });
      
      // Reset selection
      gameState.selectedTarget = null;
    }

    // Helper functions
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function getColorCode(color) {
      const colorCodes = {
        red: '#e74c3c',
        green: '#2ecc71',
        blue: '#3498db',
        white: '#95a5a6',
        yellow: '#f1c40f'
      };
      return colorCodes[color] || '#000000';
    }

    function getPastelColorCode(color) {
      const pastelColorCodes = {
        red: '#ffcccb',     // Light Red
        green: '#90ee90',   // Light Green
        blue: '#add8e6',    // Light Blue
        white: '#f5f5f5',   // Off-White (very light gray)
        yellow: '#ffffcc'   // Light Yellow
      };
      return pastelColorCodes[color] || '#e0e0e0'; // Default to a light gray
    }

    // Socket event handlers
    function setupSocketEvents() {
      socket.on('connect', () => {
        console.log('Connected to server');
        serverInfoEl.textContent = `Connected to server: ${serverAddressInput.value}`;
        // No automatic reconnection attempt on connect anymore
      });
      
      socket.on('gameState', (state) => {
        // Update game state
        // Ensure playerId from localStorage is preferred if this is an initial load/reconnect
        const localPId = localStorage.getItem('lostCitiesPlayerId');
        gameState = {...gameState, ...state };
        if (localPId && (!gameState.playerId || gameState.playerId !== localPId)) {
            // This case might occur if server sends state before reconnected event fully sets client's view
            // Or if server state's playerId is somehow different. Prioritize our known persistent ID.
            // However, the server should be authoritative on game state.
            // The key is that gameState.playerId on client should be the persistentId.
        }
        console.log(`DEBUG: socket.on('gameState') - Received gamePhase: ${state.gamePhase}, currentTurn: ${state.currentTurn}, client's playerId: ${gameState.playerId}`);
        renderGameState();
      });

      // Removed 'reconnected' event handler
      
      socket.on('playerJoined', (data) => {
        // data.playerId is persistentPlayerId
        if (data.playerId !== gameState.playerId) {
          gameState.opponentName = data.playerName;
          addToHistory(`${data.playerName} joined the game`);
        }
        renderGameState(); // Opponent name might have changed
      });
      
      socket.on('gameStarted', (data) => {
        // data.currentTurn is persistentPlayerId
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = 'selectCard';
        addToHistory('Game started!');
        renderGameState();
      });
      
      socket.on('turnChanged', (data) => {
        // data.currentTurn is persistentPlayerId
        const previousTurn = gameState.currentTurn; // Capture current turn *before* updating it
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = data.gamePhase;
        
        if (gameState.currentTurn === gameState.playerId) {
          // Play sound only if the turn has *changed* to this player,
          // and it wasn't null before (i.e., not the very first turn of the game setup)
          if (previousTurn !== gameState.playerId && previousTurn !== null) { 
            playTurnSound();
          }
          addToHistory('Your turn');
        } else {
          addToHistory(`${gameState.opponentName}'s turn`);
        }
        renderGameState();
      });
      
      socket.on('cardPlayed', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} played a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDiscarded', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} discarded a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDrawn', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        const source = data.source === 'deck' ? 'the deck' : `the ${data.color} discard pile`;
        addToHistory(`${playerNameDisplay} drew a card from ${source}`);
      });

      socket.on('opponentDisconnected', (data) => {
        showNotification(data.message);
        addToHistory(data.message);
        // Transition to a state where the user must start/join a new game
        gameStatus.textContent = data.message + " Please start or join a new game.";
        // Disable game controls, effectively ending the game on the client side
        playCardBtn.disabled = true;
        discardCardBtn.disabled = true;
        drawDeckBtn.disabled = true;
        drawDiscardBtn.disabled = true;
        // Optionally, redirect to setup screen or show a "New Game" button
        // For now, just update status and disable buttons.
        // Consider clearing gameId to prevent accidental reuse if not starting fresh
        gameState.gameId = null; 
      });

      // Removed 'playerReconnected' event handler
      
      socket.on('gameOver', (data) => {
        // data.scores keys are persistentPlayerIds
        gameState.gamePhase = 'gameOver';
        if (data.scores && gameState.playerId) {
            gameState.playerScore = data.scores[gameState.playerId] || 0;
        }
        
        const opponentPersistentId = Object.keys(data.scores || {}).find(id => id !== gameState.playerId);
        if (opponentPersistentId && data.scores) {
          gameState.opponentScore = data.scores[opponentPersistentId] || 0;
        }
        
        let message = 'Game over! ';
        if (gameState.playerScore > gameState.opponentScore) {
          message += 'You win!';
        } else if (gameState.playerScore < gameState.opponentScore) {
          message += `${gameState.opponentName || 'Opponent'} wins!`;
        } else {
          message += "It's a tie!";
        }
        
        addToHistory(message);
        showNotification(message);
        renderGameState();

        // Clear stored game data as game is over
        localStorage.removeItem('lostCitiesGameId');
        localStorage.removeItem('lostCitiesPlayerId');
        localStorage.removeItem('lostCitiesPlayerName');
        gameState.gameId = null; 
        // gameState.playerId = null; // Keep playerId for score display until new game
      });
      
      socket.on('error', (error) => {
        showNotification(`Error: ${error.message}`);
        // Removed reconnection-specific error handling
      });
      
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        showNotification('Disconnected from server. Please start or join a new game.');
        serverInfoEl.textContent = 'Disconnected from server.';
        // Transition to a state where the user must start/join a new game
        setupScreen.style.display = 'block';
        gameContainer.style.display = 'none';
        gameStatus.textContent = 'Disconnected. Please start or join a new game.';
        // Clear any potentially stale game state
        gameState.gameId = null;
        gameState.playerId = null;
      });
    }

    function connectToServer(serverAddress, isCreatingGame, isJoiningGame) {
      try {
        if (!audioContext) { // Initialize AudioContext on first user gesture
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (socket && socket.connected) {
            socket.disconnect(); // Disconnect existing socket if any before creating new
        }
        socket = io(serverAddress, {
            reconnection: false // Disable automatic reconnection
        });
        gameState.playerName = playerNameInput.value.trim() || localStorage.getItem('lostCitiesPlayerName') || (isCreatingGame ? 'Player 1' : 'Player 2');
        localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Store/update name

        setupSocketEvents(); // Setup handlers for the new socket instance
        
        if (isCreatingGame) {
          socket.emit('createGame', { playerName: gameState.playerName });
        } else if (isJoiningGame) {
          socket.emit('joinGame', { playerName: gameState.playerName });
        }
        // No third case for reconnection attempts
      } catch (error) {
        alert(`Error connecting to server: ${error.message}`);
      }
    }

    // Create game button click handler
    createGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, true, false);
    });


    // Join game button click handler
    joinGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, false, true);
    });

    // Modify setupSocketEvents to remove localStorage setting for gameId/playerId
    const originalSetupSocketEvents = setupSocketEvents;
    setupSocketEvents = () => {
      originalSetupSocketEvents(); // Call original events

      if (socket) { // Ensure socket exists before adding new listeners
        socket.on('gameCreated', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          // localStorage.setItem('lostCitiesGameId', data.gameId); // Removed
          // localStorage.setItem('lostCitiesPlayerId', data.playerId); // Removed
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory('Game created. Waiting for opponent...');
          showNotification('Game created! Waiting for opponent to join...');
        });

        socket.on('gameJoined', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          gameState.opponentName = data.hostName;
          // localStorage.setItem('lostCitiesGameId', data.gameId); // Removed
          // localStorage.setItem('lostCitiesPlayerId', data.playerId); // Removed
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory(`Joined game hosted by ${data.hostName}`);
          showNotification(`Joined game! Playing against ${data.hostName}`);
        });
      }
    };


    // Play card button click handler
    playCardBtn.addEventListener('click', playCard);
    
    // Discard card button click handler
    discardCardBtn.addEventListener('click', discardCard);
    
    // Draw deck button click handler
    drawDeckBtn.addEventListener('click', drawFromDeck);
    
    // Draw discard button click handler
    drawDiscardBtn.addEventListener('click', drawFromDiscard);

    // Initial page load logic
    document.addEventListener('DOMContentLoaded', () => {
      // getLocalIpAddress(); // This function is server-side, remove call from client

      // Load only player name and server address from localStorage
      const storedPlayerName = localStorage.getItem('lostCitiesPlayerName');
      const serverAddress = localStorage.getItem('lostCitiesServerAddress') || 'http://192.168.1.114:3000';

      playerNameInput.value = storedPlayerName || '';
      serverAddressInput.value = serverAddress;

      // Always show setup screen on load, no automatic reconnection
      setupScreen.style.display = 'block';
      gameContainer.style.display = 'none';

      // Save server address when it changes
      serverAddressInput.addEventListener('change', () => {
        localStorage.setItem('lostCitiesServerAddress', serverAddressInput.value.trim());
      });
    });

    // Function to play a turn notification sound
    function playTurnSound() {
      if (!audioContext || audioContext.state === 'suspended') {
        audioContext.resume(); // Attempt to resume if suspended
      }
      if (!audioContext || audioContext.state !== 'running') {
        console.warn('AudioContext not running, cannot play sound.');
        return;
      }

      const now = audioContext.currentTime;
      const fundamentalHz = 523.25; // C5 note

      // Frequencies for the bell sound (fundamental, a fifth, an octave)
      const frequencies = [
        fundamentalHz,
        fundamentalHz * 1.5,
        fundamentalHz * 2.0
      ];

      // Gain values for each partial (fundamental is loudest)
      const initialGains = [0.15, 0.105, 0.075]; // Increased volume
      // Decay times for each partial (overtones decay slightly faster)
      const decayTimes = [1.0, 0.8, 0.6];

      frequencies.forEach((freq, index) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);

        // Set initial gain with a very quick attack
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(initialGains[index], now + 0.01);
        
        // Exponential decay
        gain.gain.exponentialRampToValueAtTime(0.0001, now + decayTimes[index]);

        osc.start(now);
        osc.stop(now + decayTimes[index] + 0.1); // Stop oscillator shortly after gain is negligible
      });
    }
  </script>
</body>
</html>
