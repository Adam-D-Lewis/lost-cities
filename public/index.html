<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lost Cities - Local Network Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
  <style>
    body {
      font-family: 'Nunito', sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e9ecf1 100%);
      margin: 0;
      padding: 0;
      color: #4A4A4A; 
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 15px; /* Increased padding for better spacing */
    }
    h1 {
      color: #333;
      text-align: center;
      font-size: 2.2em;
      margin-bottom: 20px;
      font-weight: 700;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
    }
    .game-status {
      text-align: center;
      font-size: 1.1em; 
      margin-bottom: 15px; 
      padding: 12px 20px; 
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 25px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      font-weight: 600;
    }
    .scores {
      display: flex;
      justify-content: space-around;
      margin-bottom: 10px; /* Reduced margin */
    }
    .score-card {
      background-color: white;
      padding: 12px 20px; 
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      min-width: 140px; 
      text-align: center;
      transition: all 0.3s ease;
    }
    .score-card.active {
      border: 2px solid #5D9CEC; /* New accent color */
      box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 0 0 4px rgba(93, 156, 236, 0.2); /* Glow effect */
      transform: translateY(-3px);
    }
    /* Removed .color-scores and .color-score-item styles */
    .column-color-score {
      font-size: 1em; /* Slightly larger for better visibility */
      font-weight: 700; /* Bold */
      margin: 8px 0;
      padding: 4px 8px;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.1); /* Subtle background to pop slightly */
      text-align: center;
      min-width: 50px; /* Ensure it has some width */
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .board {
      display: flex; /* To arrange columns and deck area side-by-side */
      justify-content: space-between;
      gap: 10px; /* Reduced gap */
      margin-bottom: 10px; /* Reduced margin */
    }
    /* .play-area styles removed */
    /* .expedition-area styles removed (or will be implicitly covered by .color-column structure) */
    .hand {
      background-color: rgba(0, 0, 0, 0.05); /* More subtle background */
      padding: 15px; 
      border-radius: 12px;
      display: flex;
      justify-content: center;
      gap: 8px; 
      margin-top: 15px; /* Added margin for spacing */
    }
    .card {
      width: 60px; 
      height: 90px; 
      background-color: white; 
      border-radius: 8px; 
      display: flex;
      flex-direction: column;
      justify-content: center; 
      align-items: center;
      font-weight: 700; /* Bolder */
      /* font-size: 1.2em; Removed, will be controlled by specific value elements */
      cursor: pointer;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
      border: 1px solid #333; /* Added a dark border for better visibility */
      position: relative; /* Ensures corner values are positioned relative to the card */
      transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
      color: #fff; 
      overflow: hidden; /* Ensures corner values don't stick out if too large */
    }
    .card:hover {
      transform: translateY(-6px) scale(1.03);
      box-shadow: 0 10px 15px rgba(0,0,0,0.12), 0 4px 6px rgba(0,0,0,0.1);
    }
    /* Card background colors will be set by JS or specific classes like .card.back */
    /* Text color for specific card backgrounds */
    .card.white, .card.yellow {
      color: #333; /* Dark text for light card backgrounds */
    }
    .card.back {
      background-color: #34495e;
      color: white; /* Explicitly white for back */
    }
    .expedition {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px; /* Reduced gap */
    }
    .expedition-cards {
      display: flex;
      flex-direction: column;
      justify-content: flex-start; /* Ensure cards stack from the top */
      height: 355px; /* Max height: 1st card (80px) + 11 more cards (11 * 25px = 275px) = 355px */
      /* gap: 2px; /* Removed gap for overlapping */
    }
    /* .discard-piles (container) styles removed */
    .controls {
      display: flex;
      justify-content: center;
      gap: 12px; 
      margin-top: 20px; /* Added margin for spacing */
      margin-bottom: 20px; 
    }
    .btn {
      padding: 10px 20px; 
      background-color: #5D9CEC; /* New accent blue */
      color: white;
      border: none;
      border-radius: 25px; /* Pill shape */
      cursor: pointer;
      font-size: 14px; 
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: all 0.2s ease-in-out;
    }
    .btn:hover {
      background-color: #4A89DC; /* Darker shade */
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background-color: #CCD1D9;
      color: #777;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .setup-screen {
      max-width: 450px; /* Slightly narrower */
      margin: 40px auto; 
      padding: 30px; 
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.1);
      text-align: center;
    }
    .input-group {
      margin-bottom: 20px; 
    }
    .input-group label { /* Style labels */
      display: block;
      text-align: left;
      font-weight: 600;
      margin-bottom: 5px;
      color: #555;
    }
    input {
      padding: 12px 18px; 
      width: calc(100% - 36px); /* Account for padding */
      border: 1px solid #DAE1E7;
      border-radius: 25px; /* Pill shape */
      font-size: 15px; 
      margin-top: 5px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    input:focus {
      outline: none;
      border-color: #5D9CEC; /* New accent blue */
      box-shadow: 0 0 0 3px rgba(93, 156, 236, 0.2);
    }
    /* .color-indicator styles removed */
    .expedition-label {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .deck {
      position: relative; /* No longer absolute */
      width: 60px; 
      height: 85px; 
      text-align: center;
    }
    .deck-count {
      /* position: absolute; bottom: -15px; */ /* Re-evaluate if needed, for now simpler */
      width: 100%;
      text-align: center;
      font-weight: bold;
      margin-top: 5px; /* Add some space if not absolutely positioned */
    }
    /* .opponent-area, .player-area styles removed */
    /* .area-label styles removed (labels will be per expedition/discard pile) */

    /* New styles for column layout */
    #game-columns-container {
      display: flex;
      flex-grow: 1; /* Takes up available space */
      justify-content: space-around; /* Distributes columns */
      gap: 5px; /* Space between color columns */
    }
    .color-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px; /* Space between opponent exp, discard, player exp */
      padding: 15px;
      border-radius: 12px; /* More rounded */
      min-width: 160px; /* Ensure columns have some base width */
      transition: background 0.5s ease; /* Smooth bg change for gradients */
      color: #333; /* Default text color for columns, ensure readability */
    }

    /* Theme styles for columns */
    .color-column.theme-red { /* Fire themed */
      position: relative;
      background: linear-gradient(135deg, #FFA07A, #FF6347); /* LightSalmon to Tomato */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-red::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/fire-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-green { /* LOTR themed */
      position: relative;
      background: linear-gradient(135deg, #90EE90, #3CB371); /* LightGreen to MediumSeaGreen */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-green::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/lotr-warrior-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-blue { /* Atlantis themed */
      position: relative;
      background: linear-gradient(135deg, #87CEEB, #4682B4); /* SkyBlue to SteelBlue */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-blue::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/atlantis-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-white { /* Dwarf themed with Aztec pattern */
      position: relative; /* For positioning the pseudo-element */
      background: linear-gradient(135deg, #D3D3D3, #A9A9A9); /* Gradient only */
      overflow: hidden; /* To clip the pseudo-element to the border-radius */
      /* Consider adding a subtle texture or pattern here if possible with CSS */
    }
    .color-column.theme-white::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/aztec-pattern.svg') repeat;
      background-size: auto; /* Or specify a size if needed */
      opacity: 0.25; /* 50% opacity for the pattern */
      z-index: 0; /* Ensures pattern is above the gradient but below content */
    }
    .color-column.theme-yellow { /* Egyptian themed */
      position: relative;
      background: linear-gradient(135deg, #F0E68C, #DAA520); /* Khaki to Goldenrod */
      overflow: hidden;
    }
    .color-column.theme-yellow::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/egypt-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }

    .deck-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center; /* Center deck vertically */
      padding: 10px;
      min-width: 80px; /* Give deck area some width */
    }
    .card-value { /* This will be the main, large, centered number */
      font-size: 2.5em; /* Larger font for the central number */
      font-weight: 700;
      line-height: 1; /* Adjust line height for better centering */
    }
    .card-value-corner {
      position: absolute;
      font-size: 0.8em; /* Smaller font for corner numbers */
      font-weight: 600;
      line-height: 1;
    }
    .card-value-top-left {
      top: 5px;
      left: 7px;
    }
    .card-value-bottom-right {
      bottom: 5px;
      right: 7px;
      transform: rotate(180deg); /* To make it appear upright from bottom right */
    }
    /* .card-suit styles removed as it's not used */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #2c3e50;
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .notification.show {
      opacity: 1;
    }
    .history-log {
      height: 80px; /* Reduced height */
      overflow-y: auto;
      background-color: white;
      padding: 8px; /* Reduced padding */
      border-radius: 5px;
      margin-bottom: 10px; /* Reduced margin */
      font-size: 12px; /* Reduced font size */
    }
    .history-log p {
      margin: 3px 0; /* Reduced margin */
    }
    .server-info {
      text-align: center;
      margin-top: 10px; /* Reduced margin */
      padding: 8px; /* Reduced padding */
      background-color: #f8f9fa;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="setup-screen" class="setup-screen">
    <h1>Lost Cities</h1>
    <p>Play Lost Cities with your partner on your local network</p>
    
    <div class="input-group">
      <label for="playerName">Your Name:</label>
      <input type="text" id="playerName" placeholder="Enter your name">
    </div>
    
    <div class="input-group">
      <label for="serverAddress">Server Address:</label>
      <input type="text" id="serverAddress" placeholder="Enter server address (e.g., http://192.168.1.100:3000)">
      <p id="local-ip"></p>
    </div>
    
    <div class="input-group">
      <button id="createGame" class="btn">Create Game</button>
      <button id="joinGame" class="btn">Join Game</button>
    </div>
  </div>

  <div id="game-container" class="container" style="display: none;">
    <h1>Lost Cities</h1>
    <div id="game-status" class="game-status">Waiting for opponent...</div>
    
    <div class="scores">
      <div id="player-score" class="score-card">
        <h3 id="player-name">You: 0</h3>
        <p>Total Score: <span id="player-score-value">0</span></p>
        <!-- Removed player-color-scores div -->
      </div>
      <div id="opponent-score" class="score-card">
        <h3 id="opponent-name">Opponent: 0</h3>
        <p>Total Score: <span id="opponent-score-value">0</span></p>
        <!-- Removed opponent-color-scores div -->
      </div>
    </div>

    <div class="history-log" id="history-log">
      <p>Game started. Waiting for players...</p>
    </div>
    
    <div class="board">
      <div id="game-columns-container">
        <!-- Color columns will be dynamically generated here by JavaScript -->
      </div>
      <div class="deck-area">
        <div class="deck" id="deck">
          <div class="card back">
            <div class="card-value">LC</div>
          </div>
          <div class="deck-count" id="deck-count">60</div>
        </div>
      </div>
    </div>
      
    <div class="hand" id="player-hand">
        <!-- Player's hand will be rendered here -->
      </div>
    </div>
    
    <div class="controls">
      <button id="play-card" class="btn" disabled>Play Card</button>
      <button id="discard-card" class="btn" disabled>Discard Card</button>
      <button id="draw-deck" class="btn" disabled>Draw from Deck</button>
      <button id="draw-discard" class="btn" disabled>Draw from Discard</button>
    </div>

    <div class="server-info" id="server-info"></div>
  </div>

  <div id="notification" class="notification"></div>

  <script>
    // Game state
    let gameState = {
      gameId: null, // Added to store gameId locally
      playerId: null, // This will store the persistentPlayerId
      playerName: '',
      opponentName: '',
      currentTurn: null, // This will be a persistentPlayerId
      selectedCard: null,
      selectedTarget: null,
      gamePhase: 'waiting', // waiting, selectCard, selectTarget, drawCard, gameOver
      hand: [],
      playerExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      opponentExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      discardPiles: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      deckCount: 60,
      playerScore: 0,
      opponentScore: 0,
      playerScoreDetails: { red: 0, green: 0, blue: 0, white: 0, yellow: 0 },
      opponentScoreDetails: { red: 0, green: 0, blue: 0, white: 0, yellow: 0 }
    };

    // Socket connection
    let socket;
    let audioContext; // For playing sounds
    
    // DOM Elements
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const gameStatus = document.getElementById('game-status');
    const playerNameInput = document.getElementById('playerName');
    const serverAddressInput = document.getElementById('serverAddress');
    const createGameBtn = document.getElementById('createGame');
    const joinGameBtn = document.getElementById('joinGame');
    const playerHandEl = document.getElementById('player-hand');
    // const playerExpeditionsEl = document.getElementById('player-expeditions'); // Removed
    // const opponentExpeditionsEl = document.getElementById('opponent-expeditions'); // Removed
    // const discardPilesEl = document.getElementById('discard-piles'); // Removed
    const deckEl = document.getElementById('deck');
    const deckCountEl = document.getElementById('deck-count');
    const playCardBtn = document.getElementById('play-card');
    const discardCardBtn = document.getElementById('discard-card');
    const drawDeckBtn = document.getElementById('draw-deck');
    const drawDiscardBtn = document.getElementById('draw-discard');
    const playerScoreEl = document.getElementById('player-score-value');
    const opponentScoreEl = document.getElementById('opponent-score-value');
    const playerNameEl = document.getElementById('player-name');
    const opponentNameEl = document.getElementById('opponent-name');
    const notificationEl = document.getElementById('notification');
    const historyLogEl = document.getElementById('history-log');
    const localIpEl = document.getElementById('local-ip');
    const serverInfoEl = document.getElementById('server-info');

    // Get local IP address to help setup
    // This function remains the same, but its call is moved to after DOM content loaded.

    // Show notification
    function showNotification(message) {
      notificationEl.textContent = message;
      notificationEl.classList.add('show');
      setTimeout(() => {
        notificationEl.classList.remove('show');
      }, 3000);
    }

    // Add message to history log
    function addToHistory(message) {
      const p = document.createElement('p');
      p.textContent = message;
      historyLogEl.appendChild(p);
      historyLogEl.scrollTop = historyLogEl.scrollHeight;
    }

    // Initialize the game UI
    function initializeGame() {
      setupScreen.style.display = 'none';
      gameContainer.style.display = 'block';
      
      createBoardLayout(); // New function to create the column-based layout
    }

    // initializeExpeditionAreas function removed
    // initializeDiscardPiles function removed

    // Render the game state
    function createBoardLayout() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      const gameColumnsContainer = document.getElementById('game-columns-container');
      gameColumnsContainer.innerHTML = ''; // Clear previous layout

      colors.forEach(color => {
        const columnEl = document.createElement('div');
        columnEl.className = 'color-column theme-' + color; // Apply theme class
        // columnEl.style.backgroundColor = getPastelColorCode(color); // Removed: background now handled by CSS theme class

        // 1. Opponent's Expedition Area
        const opponentExpeditionContainer = document.createElement('div');
        opponentExpeditionContainer.className = 'expedition'; 
        
        const opponentLabel = document.createElement('div');
        opponentLabel.className = 'expedition-label';
        // const opponentColorIndicator = document.createElement('span'); // Removed
        // opponentColorIndicator.className = 'color-indicator'; // Removed
        // opponentColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // opponentLabel.appendChild(opponentColorIndicator); // Removed
        opponentLabel.appendChild(document.createTextNode(`Opponent ${capitalizeFirstLetter(color)}`)); 
        
        const opponentCardsEl = document.createElement('div');
        opponentCardsEl.className = 'expedition-cards';
        opponentCardsEl.id = `opponent-${color}-expedition`;
        
        opponentExpeditionContainer.appendChild(opponentLabel);
        opponentExpeditionContainer.appendChild(opponentCardsEl);
        columnEl.appendChild(opponentExpeditionContainer);

        // Opponent's score for this color (Above Discard)
        const opponentColorScoreEl = document.createElement('div');
        opponentColorScoreEl.id = `opponent-${color}-score-display`;
        opponentColorScoreEl.className = 'column-color-score';
        opponentColorScoreEl.textContent = '0'; // Default text
        columnEl.appendChild(opponentColorScoreEl);

        // 2. Discard Pile Area
        const discardPileContainer = document.createElement('div');
        discardPileContainer.className = 'expedition'; 

        const discardLabel = document.createElement('div');
        discardLabel.className = 'expedition-label';
        // For discard, use the color indicator as well for consistency // Removed
        // const discardColorIndicator = document.createElement('span'); // Removed
        // discardColorIndicator.className = 'color-indicator'; // Removed
        // discardColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // discardLabel.appendChild(discardColorIndicator); // Removed
        discardLabel.appendChild(document.createTextNode(`Discard`));
        
        const discardCardEl = document.createElement('div');
        discardCardEl.className = 'card'; 
        discardCardEl.classList.add(color); 
        discardCardEl.id = `discard-${color}`;
        discardCardEl.dataset.color = color;
        discardCardEl.innerHTML = '<div class="card-value">-</div>'; 
        discardCardEl.addEventListener('click', () => selectDiscardTarget(color));

        discardPileContainer.appendChild(discardLabel);
        discardPileContainer.appendChild(discardCardEl);
        columnEl.appendChild(discardPileContainer);

        // Player's score for this color (Below Discard)
        const playerColorScoreEl = document.createElement('div');
        playerColorScoreEl.id = `player-${color}-score-display`;
        playerColorScoreEl.className = 'column-color-score';
        playerColorScoreEl.textContent = '0'; // Default text
        columnEl.appendChild(playerColorScoreEl);

        // 3. Player's Expedition Area
        const playerExpeditionContainer = document.createElement('div');
        playerExpeditionContainer.className = 'expedition'; 
        
        const playerLabel = document.createElement('div');
        playerLabel.className = 'expedition-label';
        // const playerColorIndicator = document.createElement('span'); // Removed
        // playerColorIndicator.className = 'color-indicator'; // Removed
        // playerColorIndicator.style.backgroundColor = getColorCode(color); // Removed
        // playerLabel.appendChild(playerColorIndicator); // Removed
        playerLabel.appendChild(document.createTextNode(`Your ${capitalizeFirstLetter(color)}`));

        const playerCardsEl = document.createElement('div');
        playerCardsEl.className = 'expedition-cards';
        playerCardsEl.id = `player-${color}-expedition`;
        playerCardsEl.dataset.color = color;
        playerCardsEl.addEventListener('click', () => selectExpeditionTarget(color));

        playerExpeditionContainer.appendChild(playerLabel);
        playerExpeditionContainer.appendChild(playerCardsEl);
        columnEl.appendChild(playerExpeditionContainer);

        gameColumnsContainer.appendChild(columnEl);
      });
      
      // Ensure deck click listener is active (it should be fine as deckEl is static HTML)
      // If deckEl was dynamically created, you'd add listener here.
      // deckEl.addEventListener('click', () => drawFromDeck()); // Already added globally
    }

    function renderGameState() {
      renderHand();
      renderExpeditions();
      renderDiscardPiles();
      updateDeckCount();
      updateScores();
      updateGameStatus();
      updateControls();
    }

    function renderHand() {
      playerHandEl.innerHTML = '';
      
      gameState.hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card';
        // cardEl.classList.add(card.color); // Color class for text, background set directly
        if (card.color === 'white' || card.color === 'yellow') {
          cardEl.classList.add(card.color); // Add class for light background text color rule
        }
        cardEl.style.backgroundColor = getColorCode(card.color); // Apply background color
        cardEl.dataset.index = index;
        cardEl.dataset.color = card.color;
        cardEl.dataset.value = card.value;
        
        const cardContent = card.value === 0 ? '💰' : card.value;

        const valueTopLeftEl = document.createElement('div');
        valueTopLeftEl.className = 'card-value-corner card-value-top-left';
        valueTopLeftEl.textContent = cardContent;
        
        const valueCenterEl = document.createElement('div');
        valueCenterEl.className = 'card-value';
        valueCenterEl.textContent = cardContent;
        
        const valueBottomRightEl = document.createElement('div');
        valueBottomRightEl.className = 'card-value-corner card-value-bottom-right';
        valueBottomRightEl.textContent = cardContent;
        
        cardEl.appendChild(valueTopLeftEl);
        cardEl.appendChild(valueCenterEl);
        cardEl.appendChild(valueBottomRightEl);
        
        if (gameState.selectedCard === index) {
          cardEl.style.border = '3px solid black';
        }
        
        cardEl.addEventListener('click', () => selectCard(index));
        playerHandEl.appendChild(cardEl);
      });
    }

    function renderExpeditions() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const playerExpEl = document.getElementById(`player-${color}-expedition`);
        const opponentExpEl = document.getElementById(`opponent-${color}-expedition`);
        
        // Clear existing cards
        playerExpEl.innerHTML = '';
        opponentExpEl.innerHTML = '';
        
        // Render player expedition
        gameState.playerExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          // cardEl.classList.add(color); // Background set directly
          if (card.color === 'white' || card.color === 'yellow') {
            cardEl.classList.add(card.color); // Add class for light background text color rule
          }
          cardEl.style.backgroundColor = getColorCode(color);
          
          const cardContent = card.value === 0 ? '💰' : card.value;

          const valueTopLeftEl = document.createElement('div');
          valueTopLeftEl.className = 'card-value-corner card-value-top-left';
          valueTopLeftEl.textContent = cardContent;
          
          const valueCenterEl = document.createElement('div');
          valueCenterEl.className = 'card-value';
          valueCenterEl.textContent = cardContent;
          
          const valueBottomRightEl = document.createElement('div');
          valueBottomRightEl.className = 'card-value-corner card-value-bottom-right';
          valueBottomRightEl.textContent = cardContent;
          
          cardEl.appendChild(valueTopLeftEl);
          cardEl.appendChild(valueCenterEl);
          cardEl.appendChild(valueBottomRightEl);
          
          if (playerExpEl.childNodes.length > 0) { // Apply negative margin to subsequent cards
            cardEl.style.marginTop = '-55px'; // 80px card height - 25px visible top = 55px overlap
          }
          playerExpEl.appendChild(cardEl);
        });
        
        // Render opponent expedition
        gameState.opponentExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          // cardEl.classList.add(color); // Background set directly
          if (card.color === 'white' || card.color === 'yellow') {
            cardEl.classList.add(card.color); // Add class for light background text color rule
          }
          cardEl.style.backgroundColor = getColorCode(color);
          
          const cardContent = card.value === 0 ? '💰' : card.value;

          const valueTopLeftEl = document.createElement('div');
          valueTopLeftEl.className = 'card-value-corner card-value-top-left';
          valueTopLeftEl.textContent = cardContent;
          
          const valueCenterEl = document.createElement('div');
          valueCenterEl.className = 'card-value';
          valueCenterEl.textContent = cardContent;
          
          const valueBottomRightEl = document.createElement('div');
          valueBottomRightEl.className = 'card-value-corner card-value-bottom-right';
          valueBottomRightEl.textContent = cardContent;
          
          cardEl.appendChild(valueTopLeftEl);
          cardEl.appendChild(valueCenterEl);
          cardEl.appendChild(valueBottomRightEl);

          if (opponentExpEl.childNodes.length > 0) { // Apply negative margin to subsequent cards
            cardEl.style.marginTop = '-55px';
          }
          opponentExpEl.appendChild(cardEl);
        });
        
        // Add highlight if selected as target
        if (gameState.selectedTarget === `expedition-${color}`) {
          playerExpEl.style.border = '3px solid black';
        } else {
          playerExpEl.style.border = 'none';
        }
      });
    }

    function renderDiscardPiles() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const discardEl = document.getElementById(`discard-${color}`);
        const discardPile = gameState.discardPiles[color];
        
        if (discardPile.length > 0) {
          const topCard = discardPile[discardPile.length - 1];
          discardEl.style.backgroundColor = getColorCode(topCard.color);
          if (topCard.color === 'white' || topCard.color === 'yellow') {
            discardEl.style.color = '#333';
          } else {
            discardEl.style.color = '#fff';
          }
          
          const cardContent = topCard.value === 0 ? '💰' : topCard.value;
          discardEl.innerHTML = `
            <div class="card-value-corner card-value-top-left">${cardContent}</div>
            <div class="card-value">${cardContent}</div>
            <div class="card-value-corner card-value-bottom-right">${cardContent}</div>
          `;
          // Reset box-shadow and border to card defaults if a card is present
          discardEl.style.boxShadow = ''; // Will revert to CSS rule for .card
          discardEl.style.border = '';    // Will revert to CSS rule for .card
        } else {
          discardEl.style.backgroundColor = '#E9E9E9'; // Light grey background for empty pile
          discardEl.style.color = '#333'; // Placeholder text color
          // For empty state, just a single central placeholder is fine.
          discardEl.innerHTML = '<div class="card-value">-</div>'; 
          discardEl.style.boxShadow = 'inset 0px 1px 4px rgba(0, 0, 0, 0.2)'; // Subtle inset shadow
          discardEl.style.border = '1px dashed #777'; // Dashed border for empty state
        }
        
        // Add highlight if selected as target
        // Reset border first, then apply if selected.
        // The border style for empty discard piles is now set above.
        // The default card border is handled by the .card class.
        // So, we only need to handle the 'selected' black border.
        if (gameState.selectedTarget === `discard-${color}`) {
          discardEl.style.border = '3px solid black';
        } else {
          // If not selected, and it's an empty pile, it keeps its dashed border.
          // If not selected, and it's a card, it keeps its default .card border.
          // So, if it's NOT empty and NOT selected, we ensure it has the default card border.
          if (discardPile.length > 0) { // If it has a card
             discardEl.style.border = '1px solid #333'; // Default card border
          }
          // If it's empty, the dashed border from above applies.
        }
      });
    }

    function updateDeckCount() {
      deckCountEl.textContent = gameState.deckCount;
    }

    function updateScores() {
      playerScoreEl.textContent = gameState.playerScore;
      opponentScoreEl.textContent = gameState.opponentScore;
      
      playerNameEl.textContent = `${gameState.playerName}`; // Name only, score is separate
      opponentNameEl.textContent = `${gameState.opponentName}`; // Name only

      const colors = ['red', 'green', 'blue', 'white', 'yellow'];

      colors.forEach(color => {
        // Update player's color score in the column
        const playerColorScoreDisplayEl = document.getElementById(`player-${color}-score-display`);
        if (playerColorScoreDisplayEl && gameState.playerScoreDetails) {
          playerColorScoreDisplayEl.textContent = `${gameState.playerScoreDetails[color] || 0}`;
        }

        // Update opponent's color score in the column
        const opponentColorScoreDisplayEl = document.getElementById(`opponent-${color}-score-display`);
        if (opponentColorScoreDisplayEl && gameState.opponentScoreDetails) {
          opponentColorScoreDisplayEl.textContent = `${gameState.opponentScoreDetails[color] || 0}`;
        }
      });
    }

    function updateGameStatus() {
      const playerScoreCard = document.getElementById('player-score');
      const opponentScoreCard = document.getElementById('opponent-score');
      
      playerScoreCard.classList.remove('active');
      opponentScoreCard.classList.remove('active');
      
      if (gameState.gamePhase === 'waiting') {
        gameStatus.textContent = 'Waiting for opponent...';
      } else if (gameState.gamePhase === 'gameOver') {
        gameStatus.textContent = 'Game Over!';
      } else if (gameState.currentTurn === gameState.playerId) {
        playerScoreCard.classList.add('active');
        
        if (gameState.gamePhase === 'selectCard') {
          if (gameState.selectedCard !== null) {
            if (gameState.selectedTarget && gameState.selectedTarget.startsWith('discard')) {
              gameStatus.textContent = 'Card and discard pile selected. Click "Discard Card".';
            } else {
              // If an expedition is selected, it's just for visual feedback or drawing, not for playing.
              gameStatus.textContent = 'Card selected. Click "Play Card" (plays to its color) or "Discard Card".';
            }
          } else {
            gameStatus.textContent = 'Your turn: Select a card to play or discard';
          }
        } else if (gameState.gamePhase === 'drawCard') {
          gameStatus.textContent = 'Draw a card from the deck or a discard pile';
        }
      } else {
        opponentScoreCard.classList.add('active');
        gameStatus.textContent = `${gameState.opponentName}'s turn`;
      }
    }

    function updateControls() {
      const isPlayerTurn = gameState.currentTurn === gameState.playerId;
      const cardSelected = gameState.selectedCard !== null;
      const targetSelected = gameState.selectedTarget !== null;
      const isSelectCardPhase = gameState.gamePhase === 'selectCard';
      const isDrawCardPhase = gameState.gamePhase === 'drawCard';
      
      playCardBtn.disabled = !(isPlayerTurn && cardSelected && isSelectCardPhase);
      // For discardCardBtn: enabled if it's player's turn, card selected, in selectCard phase, AND
      // (no target is selected OR a discard pile is selected)
      let canDiscard = false;
      if (isPlayerTurn && cardSelected && isSelectCardPhase) {
        // Ensure selectedTarget is a string before calling startsWith if targetSelected is true
        if (!targetSelected || (targetSelected && typeof gameState.selectedTarget === 'string' && gameState.selectedTarget.startsWith('discard'))) {
          canDiscard = true;
        }
      }
      discardCardBtn.disabled = !canDiscard;
      
      drawDeckBtn.disabled = !(isPlayerTurn && isDrawCardPhase);
      
      let canDrawFromDiscard = false;
      // Check player turn and phase first, then if a target is selected, then if it's a discard pile.
      if (isPlayerTurn && isDrawCardPhase && targetSelected && typeof gameState.selectedTarget === 'string' && gameState.selectedTarget.startsWith('discard')) {
        canDrawFromDiscard = true;
      }
      // For debugging, you might uncomment this log:
      console.log(`DEBUG: updateControls - DrawDiscard: isPlayerTurn=${isPlayerTurn}, isDrawCardPhase=${isDrawCardPhase}, targetSelected=${targetSelected}, selectedTarget="${gameState.selectedTarget}", typeof selectedTarget="${typeof gameState.selectedTarget}", canDrawFromDiscard=${canDrawFromDiscard}`);
      drawDiscardBtn.disabled = !canDrawFromDiscard;
    }

    // Game actions
    function selectCard(index) {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'selectCard') {
        return;
      }
      
      if (gameState.selectedCard === index) {
        gameState.selectedCard = null;
      } else {
        gameState.selectedCard = index;
      }
      
      renderGameState();
    }

    function selectExpeditionTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      if (gameState.selectedTarget === `expedition-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `expedition-${color}`;
      }
      
      renderGameState();
    }

    function selectDiscardTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      // Can't draw from empty discard pile
      if (gameState.gamePhase === 'drawCard' && gameState.discardPiles[color].length === 0) {
        showNotification("Can't draw from an empty discard pile");
        console.log(`DEBUG: selectDiscardTarget - Attempted to select empty discard pile: ${color}`);
        return;
      }
      
      console.log(`DEBUG: selectDiscardTarget - Color: ${color}, Current Phase: ${gameState.gamePhase}, Pile content:`, JSON.stringify(gameState.discardPiles[color]));
      if (gameState.selectedTarget === `discard-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `discard-${color}`;
      }
      
      renderGameState();
    }

    function playCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      const targetColor = card.color; // Play to the card's own color expedition
      
      // Check if card can be played on this expedition (this check might seem redundant now, but good for safety)
      if (card.color !== targetColor) {
        showNotification(`Can only play ${card.color} cards on the ${card.color} expedition`);
        return;
      }
      
      // Check if card value is valid (must be ascending)
      const expedition = gameState.playerExpeditions[targetColor];
      if (expedition.length > 0) {
        const lastCardValue = expedition[expedition.length - 1].value;
        if (card.value <= lastCardValue && lastCardValue !== 0) {
          showNotification(`Card value must be higher than the last card (${lastCardValue})`);
          return;
        }
      }
      
      // Send play card action to server
      socket.emit('playCard', {
        cardIndex: gameState.selectedCard,
        target: targetColor
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function discardCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      let targetColor = card.color;
      
      // If a specific discard pile was selected, use that instead
      if (gameState.selectedTarget && gameState.selectedTarget.startsWith('discard')) {
        targetColor = gameState.selectedTarget.split('-')[1];
      }
      
      // Send discard card action to server
      socket.emit('discardCard', {
        cardIndex: gameState.selectedCard,
        color: targetColor
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function drawFromDeck() {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'drawCard') {
        return;
      }
      
      // Send draw from deck action to server
      socket.emit('drawCard', { source: 'deck' });
      
      // Reset selection
      gameState.selectedTarget = null;
    }

    function drawFromDiscard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'drawCard' ||
          !gameState.selectedTarget ||
          !gameState.selectedTarget.startsWith('discard')) {
        return;
      }
      
      const color = gameState.selectedTarget.split('-')[1];
      
      // Check if discard pile has cards
      if (gameState.discardPiles[color].length === 0) {
        showNotification(`Discard pile is empty`);
        return;
      }
      
      // Send draw from discard action to server
      socket.emit('drawCard', { source: 'discard', color: color });
      
      // Reset selection
      gameState.selectedTarget = null;
    }

    // Helper functions
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function getColorCode(color) {
      const colorCodes = {
        red: '#EF5350',     // A softer, modern Red
        green: '#66BB6A',   // A softer, modern Green
        blue: '#42A5F5',    // A softer, modern Blue
        white: '#BDBDBD',   // A light, neutral Grey for "white"
        yellow: '#FFEE58'   // A vibrant, modern Yellow
      };
      return colorCodes[color] || '#9E9E9E'; // Default to a mid-grey
    }

    function getPastelColorCode(color) {
      const pastelColorCodes = {
        red: '#FFEBEE',     // Light Red
        green: '#E8F5E9',   // Light Green
        blue: '#E3F2FD',    // Light Blue
        white: '#FAFAFA',   // Very Light Grey (almost white)
        yellow: '#FFFDE7'   // Light Yellow
      };
      return pastelColorCodes[color] || '#F5F5F5'; // Default to a very light gray
    }

    // Socket event handlers
    function setupSocketEvents() {
      socket.on('connect', () => {
        console.log('Connected to server');
        serverInfoEl.textContent = `Connected to server: ${serverAddressInput.value}`;
        // No automatic reconnection attempt on connect anymore
      });
      
      socket.on('gameState', (state) => {
        // Update game state
        // Ensure playerId from localStorage is preferred if this is an initial load/reconnect
        const localPId = localStorage.getItem('lostCitiesPlayerId');
        gameState = {...gameState, ...state };
        // Ensure score details are objects even if not sent by server initially
        gameState.playerScoreDetails = state.playerScoreDetails || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        gameState.opponentScoreDetails = state.opponentScoreDetails || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };

        if (localPId && (!gameState.playerId || gameState.playerId !== localPId)) {
            // This case might occur if server sends state before reconnected event fully sets client's view
            // Or if server state's playerId is somehow different. Prioritize our known persistent ID.
            // However, the server should be authoritative on game state.
            // The key is that gameState.playerId on client should be the persistentId.
        }
        console.log(`DEBUG: socket.on('gameState') - Received gamePhase: ${state.gamePhase}, currentTurn: ${state.currentTurn}, client's playerId: ${gameState.playerId}`);
        renderGameState();
      });

      // Removed 'reconnected' event handler
      
      socket.on('playerJoined', (data) => {
        // data.playerId is persistentPlayerId
        if (data.playerId !== gameState.playerId) {
          gameState.opponentName = data.playerName;
          addToHistory(`${data.playerName} joined the game`);
        }
        renderGameState(); // Opponent name might have changed
      });
      
      socket.on('gameStarted', (data) => {
        // data.currentTurn is persistentPlayerId
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = 'selectCard';
        addToHistory('Game started!');
        renderGameState();
      });
      
      socket.on('turnChanged', (data) => {
        // data.currentTurn is persistentPlayerId
        const previousTurn = gameState.currentTurn; // Capture current turn *before* updating it
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = data.gamePhase;
        
        if (gameState.currentTurn === gameState.playerId) {
          // Play sound only if the turn has *changed* to this player,
          // and it wasn't null before (i.e., not the very first turn of the game setup)
          if (previousTurn !== gameState.playerId && previousTurn !== null) { 
            playTurnSound();
          }
          addToHistory('Your turn');
        } else {
          addToHistory(`${gameState.opponentName}'s turn`);
        }
        renderGameState();
      });
      
      socket.on('cardPlayed', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} played a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDiscarded', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} discarded a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDrawn', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        const source = data.source === 'deck' ? 'the deck' : `the ${data.color} discard pile`;
        addToHistory(`${playerNameDisplay} drew a card from ${source}`);
      });

      socket.on('opponentDisconnected', (data) => {
        showNotification(data.message);
        addToHistory(data.message);
        // Transition to a state where the user must start/join a new game
        gameStatus.textContent = data.message + " Please start or join a new game.";
        // Disable game controls, effectively ending the game on the client side
        playCardBtn.disabled = true;
        discardCardBtn.disabled = true;
        drawDeckBtn.disabled = true;
        drawDiscardBtn.disabled = true;
        // Optionally, redirect to setup screen or show a "New Game" button
        // For now, just update status and disable buttons.
        // Consider clearing gameId to prevent accidental reuse if not starting fresh
        gameState.gameId = null; 
      });

      // Removed 'playerReconnected' event handler
      
      socket.on('gameOver', (data) => {
        // data.scores keys are persistentPlayerIds
        gameState.gamePhase = 'gameOver';
        if (data.scores && gameState.playerId && data.scores[gameState.playerId]) {
            gameState.playerScore = data.scores[gameState.playerId].total || 0;
            gameState.playerScoreDetails = data.scores[gameState.playerId].details || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        }
        
        const opponentPersistentId = Object.keys(data.scores || {}).find(id => id !== gameState.playerId);
        if (opponentPersistentId && data.scores && data.scores[opponentPersistentId]) {
          gameState.opponentScore = data.scores[opponentPersistentId].total || 0;
          gameState.opponentScoreDetails = data.scores[opponentPersistentId].details || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        }
        
        let message = 'Game over! ';
        if (gameState.playerScore > gameState.opponentScore) {
          message += 'You win!';
        } else if (gameState.playerScore < gameState.opponentScore) {
          message += `${gameState.opponentName || 'Opponent'} wins!`;
        } else {
          message += "It's a tie!";
        }
        
        addToHistory(message);
        showNotification(message);
        renderGameState();

        // Clear stored game data as game is over
        localStorage.removeItem('lostCitiesGameId');
        localStorage.removeItem('lostCitiesPlayerId');
        localStorage.removeItem('lostCitiesPlayerName');
        gameState.gameId = null; 
        // gameState.playerId = null; // Keep playerId for score display until new game
      });
      
      socket.on('error', (error) => {
        showNotification(`Error: ${error.message}`);
        // Removed reconnection-specific error handling
      });
      
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        showNotification('Disconnected from server. Please start or join a new game.');
        serverInfoEl.textContent = 'Disconnected from server.';
        // Transition to a state where the user must start/join a new game
        setupScreen.style.display = 'block';
        gameContainer.style.display = 'none';
        gameStatus.textContent = 'Disconnected. Please start or join a new game.';
        // Clear any potentially stale game state
        gameState.gameId = null;
        gameState.playerId = null;
      });
    }

    function connectToServer(serverAddress, isCreatingGame, isJoiningGame) {
      try {
        if (!audioContext) { // Initialize AudioContext on first user gesture
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (socket && socket.connected) {
            socket.disconnect(); // Disconnect existing socket if any before creating new
        }
        socket = io(serverAddress, {
            reconnection: false // Disable automatic reconnection
        });
        gameState.playerName = playerNameInput.value.trim() || localStorage.getItem('lostCitiesPlayerName') || (isCreatingGame ? 'Player 1' : 'Player 2');
        localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Store/update name

        setupSocketEvents(); // Setup handlers for the new socket instance
        
        if (isCreatingGame) {
          socket.emit('createGame', { playerName: gameState.playerName });
        } else if (isJoiningGame) {
          socket.emit('joinGame', { playerName: gameState.playerName });
        }
        // No third case for reconnection attempts
      } catch (error) {
        alert(`Error connecting to server: ${error.message}`);
      }
    }

    // Create game button click handler
    createGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, true, false);
    });


    // Join game button click handler
    joinGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, false, true);
    });

    // Modify setupSocketEvents to remove localStorage setting for gameId/playerId
    const originalSetupSocketEvents = setupSocketEvents;
    setupSocketEvents = () => {
      originalSetupSocketEvents(); // Call original events

      if (socket) { // Ensure socket exists before adding new listeners
        socket.on('gameCreated', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          // localStorage.setItem('lostCitiesGameId', data.gameId); // Removed
          // localStorage.setItem('lostCitiesPlayerId', data.playerId); // Removed
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory('Game created. Waiting for opponent...');
          showNotification('Game created! Waiting for opponent to join...');
        });

        socket.on('gameJoined', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          gameState.opponentName = data.hostName;
          // localStorage.setItem('lostCitiesGameId', data.gameId); // Removed
          // localStorage.setItem('lostCitiesPlayerId', data.playerId); // Removed
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory(`Joined game hosted by ${data.hostName}`);
          showNotification(`Joined game! Playing against ${data.hostName}`);
        });
      }
    };


    // Play card button click handler
    playCardBtn.addEventListener('click', playCard);
    
    // Discard card button click handler
    discardCardBtn.addEventListener('click', discardCard);
    
    // Draw deck button click handler
    drawDeckBtn.addEventListener('click', drawFromDeck);
    
    // Draw discard button click handler
    drawDiscardBtn.addEventListener('click', drawFromDiscard);

    // Initial page load logic
    document.addEventListener('DOMContentLoaded', () => {
      // getLocalIpAddress(); // This function is server-side, remove call from client

      // Load only player name and server address from localStorage
      const storedPlayerName = localStorage.getItem('lostCitiesPlayerName');
      const serverAddress = localStorage.getItem('lostCitiesServerAddress') || 'http://192.168.1.114:3000';

      playerNameInput.value = storedPlayerName || '';
      serverAddressInput.value = serverAddress;

      // Always show setup screen on load, no automatic reconnection
      setupScreen.style.display = 'block';
      gameContainer.style.display = 'none';

      // Save server address when it changes
      serverAddressInput.addEventListener('change', () => {
        localStorage.setItem('lostCitiesServerAddress', serverAddressInput.value.trim());
      });
    });

    // Function to play a turn notification sound
    function playTurnSound() {
      if (!audioContext || audioContext.state === 'suspended') {
        audioContext.resume(); // Attempt to resume if suspended
      }
      if (!audioContext || audioContext.state !== 'running') {
        console.warn('AudioContext not running, cannot play sound.');
        return;
      }

      const now = audioContext.currentTime;
      const fundamentalHz = 523.25; // C5 note

      // Frequencies for the bell sound (fundamental, a fifth, an octave)
      const frequencies = [
        fundamentalHz,
        fundamentalHz * 1.5,
        fundamentalHz * 2.0
      ];

      // Gain values for each partial (fundamental is loudest)
      const initialGains = [0.15, 0.105, 0.075]; // Increased volume
      // Decay times for each partial (overtones decay slightly faster)
      const decayTimes = [1.0, 0.8, 0.6];

      frequencies.forEach((freq, index) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);

        // Set initial gain with a very quick attack
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(initialGains[index], now + 0.01);
        
        // Exponential decay
        gain.gain.exponentialRampToValueAtTime(0.0001, now + decayTimes[index]);

        osc.start(now);
        osc.stop(now + decayTimes[index] + 0.1); // Stop oscillator shortly after gain is negligible
      });
    }
  </script>
</body>
</html>
