<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Lost Cities - Local Network Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.1/socket.io.js"></script>
  <style>
    body {
      font-family: 'Nunito', sans-serif;
      background: linear-gradient(135deg, #f5f7fa 0%, #e9ecf1 100%);
      margin: 0;
      padding: 0;
      color: #4A4A4A; 
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px; /* Reduced padding for mobile */
      box-sizing: border-box; /* Added for predictable sizing */
      width: 100%; /* Ensure full width */
    }
    h1 {
      color: #333;
      text-align: center;
      font-size: 2.2em;
      margin-bottom: 20px;
      margin-top: 0;
      font-weight: 700;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
    }
    .title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-bottom: 10px;
    }
    .game-status {
      text-align: center;
      font-size: 1.1em; 
      margin-bottom: 15px; 
      padding: 12px 20px; 
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 25px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.07);
      font-weight: 600;
    }
    .score-card {
      background-color: white;
      padding: 15px 30px; /* Reduced top/bottom padding to 15px, kept left/right at 30px */
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      min-width: 140px; 
      text-align: center;
      transition: all 0.3s ease;
    }
    .score-card.active {
      border: 2px solid #5D9CEC; /* New accent color */
      box-shadow: 0 4px 12px rgba(0,0,0,0.08), 0 0 0 4px rgba(93, 156, 236, 0.2); /* Glow effect */
      transform: translateY(-3px);
    }
    .column-color-score {
      font-size: 1em; /* Slightly larger for better visibility */
      font-weight: 700; /* Bold */
      margin: 8px 0;
      padding: 4px 8px;
      border-radius: 4px;
      background-color: rgba(0, 0, 0, 0.3); /* Darker background */
      color: #fff !important; /* Ensure text is white, overriding column theme */
      text-align: center;
      min-width: 50px; /* Ensure it has some width */
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .board {
      display: flex; /* To arrange columns and deck area side-by-side */
      justify-content: space-between;
      gap: 5px; /* Further reduced gap for mobile */
      margin-bottom: 10px; /* Reduced margin */
      flex-grow: 1; /* Allow board to take available vertical space */
      flex-wrap: wrap; /* Allow wrapping on small screens */
    }
    .hand {
      background-color: rgba(0, 0, 0, 0.05); /* More subtle background */
      padding: 15px; 
      border-radius: 12px;
      display: flex;
      justify-content: center;
      gap: 8px; 
      /* margin-top: 15px; /* Removed, new parent #player-action-row will handle spacing */
      min-height: 45px; /* Ensure row has height even if hand is empty (card height) */
    }
    .card {
      width: 40px; /* Reduced size for mobile */
      height: 45px; /* Reduced size for mobile */
      background-color: white; 
      border-radius: 6px; /* Slightly reduced for mobile */
      display: flex;
      flex-direction: column;
      justify-content: center; 
      align-items: center;
      font-weight: 700; /* Bolder */
      /* font-size: 1.2em; Removed, will be controlled by specific value elements */
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.08);
      border: 1px solid #333; /* Added a dark border for better visibility */
      position: relative; /* Ensures corner values are positioned relative to the card */
      transition: transform 0.25s ease-out, box-shadow 0.25s ease-out;
      color: #fff; 
      overflow: hidden; /* Ensures corner values don't stick out if too large */
    }

    /* General pseudo-element for card patterns */
    .card::before {
      content: "";
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-repeat: repeat;
      background-size: auto; /* Or a specific size if patterns are too large/small */
      opacity: 0.5; /* Opacity for the pattern layer on cards */
      z-index: 0; /* Places it above the card's own background-color, but below content */
      pointer-events: none; /* So it doesn't interfere with card interactions */
    }

    /* Specific patterns for each theme on cards */
    .card.theme-red::before    { background-image: url('assets/fire-pattern.svg'); }
    .card.theme-green::before  { background-image: url('assets/lotr-warrior-pattern.svg'); }
    .card.theme-blue::before   { background-image: url('assets/atlantis-pattern.svg'); }
    .card.theme-white::before  { background-image: url('assets/aztec-pattern.svg'); }
    .card.theme-yellow::before { background-image: url('assets/egypt-pattern.svg'); }

    .card:hover {
      transform: translateY(-6px) scale(1.03);
      box-shadow: 0 10px 15px rgba(0,0,0,0.12), 0 4px 6px rgba(0,0,0,0.1);
    }
    /* Text color for specific card backgrounds */
    .card.white, .card.yellow {
      color: #333; /* Dark text for light card backgrounds */
    }
    .card.back {
      background-color: #34495e;
      color: white; /* Explicitly white for back */
    }
    .expedition {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px; /* Reduced gap */
    }
    .expedition-cards {
      position: relative; /* For absolute positioning of cards */
      width: 100%; /* Fill parent width */
      height: 250px; /* Reduced height for mobile */
      /* display: flex, flex-direction, justify-content removed */
    }
    .card-expedition-area {
      align-self: flex-start; /* Align to the start of the color-column's cross-axis (left) */
      width: 100%; /* Make the container utilize the full width of the color-column */
    }
    /* .discard-piles (container) styles removed */
    .controls {
      display: flex;
      justify-content: center;
      flex-wrap: wrap; /* Allow buttons to wrap on small screens */
      gap: 8px; /* Reduced gap for mobile */
      /* margin-top and margin-bottom removed, new parent row handles spacing */
      width: 100%; /* Ensure full width */
    }
    .action-buttons-row {
      min-height: 60px; /* Min height for the button row */
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 15px; /* Consistent padding with .hand */
      box-sizing: border-box;
      background-color: rgba(0, 0, 0, 0.05); /* Same as .hand */
      border-radius: 12px; /* Same as .hand */
    }
    .btn {
      padding: 8px 15px; /* Reduced padding for mobile */
      background-color: #5D9CEC; /* New accent blue */
      color: white;
      border: none;
      border-radius: 25px; /* Pill shape */
      cursor: pointer;
      font-size: 12px; /* Reduced for mobile */
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      transition: all 0.2s ease-in-out;
      margin: 2px; /* Add small margin between buttons */
    }
    .btn:hover {
      background-color: #4A89DC; /* Darker shade */
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    .btn:disabled {
      background-color: #CCD1D9;
      color: #777;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .setup-screen {
      max-width: 450px; /* Slightly narrower */
      margin: 40px auto; 
      padding: 30px; 
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.1);
      text-align: center;
    }
    .input-group {
      margin-bottom: 20px; 
    }
    .input-group label { /* Style labels */
      display: block;
      text-align: left;
      font-weight: 600;
      margin-bottom: 5px;
      color: #555;
    }
    input {
      padding: 12px 18px; 
      width: calc(100% - 36px); /* Account for padding */
      border: 1px solid #DAE1E7;
      border-radius: 25px; /* Pill shape */
      font-size: 15px; 
      margin-top: 5px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    input:focus {
      outline: none;
      border-color: #5D9CEC; /* New accent blue */
      box-shadow: 0 0 0 3px rgba(93, 156, 236, 0.2);
    }
    /* .color-indicator styles removed */
    .expedition-label {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .deck {
      position: relative; /* No longer absolute */
      width: 40px; /* Reduced for mobile */
      height: 45px; /* Reduced for mobile */
      text-align: center;
    }
    .deck-count {
      width: 100%;
      text-align: center;
      font-weight: bold;
      margin-top: 5px; /* Add some space if not absolutely positioned */
    }

    /* New styles for column layout */
    #game-columns-container {
      display: flex;
      flex-grow: 1; /* Takes up available space */
      justify-content: center; /* Center the group of columns */
      gap: 10px; /* Space between color columns */
    }
    .color-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px; /* Reduced space between elements for mobile */
      padding: 10px; /* Reduced padding for mobile */
      border-radius: 12px; /* More rounded */
      min-width: 60px; /* Reduced minimum width for mobile */
      width: calc(20% - 5px); /* Each column takes 1/5 of space minus gap */
      transition: background 0.5s ease; /* Smooth bg change for gradients */
      color: #333; /* Default text color for columns, ensure readability */
      box-sizing: border-box; /* Include padding in width calculation */
    }

    /* Theme styles for columns */
    .color-column.theme-red { /* Fire themed */
      position: relative;
      background: linear-gradient(135deg, #FFA07A, #FF6347); /* LightSalmon to Tomato */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-red::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/fire-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-green { /* LOTR themed */
      position: relative;
      background: linear-gradient(135deg, #90EE90, #3CB371); /* LightGreen to MediumSeaGreen */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-green::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/lotr-warrior-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-blue { /* Atlantis themed */
      position: relative;
      background: linear-gradient(135deg, #87CEEB, #4682B4); /* SkyBlue to SteelBlue */
      color: white; /* Text color for dark backgrounds */
      overflow: hidden;
    }
    .color-column.theme-blue::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/atlantis-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }
    .color-column.theme-white { /* Dwarf themed with Aztec pattern */
      position: relative; /* For positioning the pseudo-element */
      background: linear-gradient(135deg, #D3D3D3, #A9A9A9); /* Gradient only */
      overflow: hidden; /* To clip the pseudo-element to the border-radius */
      /* Consider adding a subtle texture or pattern here if possible with CSS */
    }
    .color-column.theme-white::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/aztec-pattern.svg') repeat;
      background-size: auto; /* Or specify a size if needed */
      opacity: 0.25; /* 50% opacity for the pattern */
      z-index: 0; /* Ensures pattern is above the gradient but below content */
    }
    .color-column.theme-yellow { /* Egyptian themed */
      position: relative;
      background: linear-gradient(135deg, #F0E68C, #DAA520); /* Khaki to Goldenrod */
      overflow: hidden;
    }
    .color-column.theme-yellow::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/egypt-pattern.svg') repeat;
      background-size: auto;
      opacity: 0.25;
      z-index: 0;
    }

    .score-and-deck-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 10px;
      width: 100%;
      box-sizing: border-box;
      flex-direction: row !important; /* Force row layout even on mobile */
      flex-wrap: nowrap !important; /* Prevent wrapping */
    }
    .score-and-deck-row .score-card {
      width: auto;
      min-width: 140px;
      max-width: 200px;
      margin: 0;
      box-sizing: border-box;
    }
    .score-and-deck-row .deck {
      margin: 0;
    }
    #player-info-in-deck-area { /* Now also a .score-card */
      /* text-align, font-weight, font-size, color are handled by .score-card or internal h3/p */
      margin-top: auto; /* Push to bottom of container */
      margin-bottom: 0; /* No space below */
      width: 100%; /* Ensure it takes full width */
      box-sizing: border-box; /* If padding is added by .score-card, ensure width is inclusive */
    }
    .score-card h3 { /* Generalize for all score cards */
      margin: 0 0 5px 0;
      font-size: 1.1em;
    }
    .score-card p { /* Generalize for all score cards */
      margin: 0;
      font-size: 1em;
    }
    #player-action-row {
      display: flex;
      align-items: center; /* Vertically align hand */
      justify-content: center; /* Center the hand */
      margin-top: 15px; /* Overall top margin for this row */
      width: 100%; /* Ensure full width */
    }
    .hand { /* Target .hand directly to make it grow */
      flex-grow: 1; /* Make the hand container take available space */
    }
    #toggle-log-btn {
      /* Specific margins removed, dimensions and padding handled by .btn-utility */
    }
    .btn-utility { /* New class for the LOG button */
      width: 40px; /* Reduced for mobile */
      height: 45px; /* Reduced for mobile */
      padding: 0; /* Remove padding to use full dimensions for text centering */
      font-size: 12px; /* Reduced for mobile */
      background-color: #7f8c8d; /* A more neutral, less prominent color (e.g., grey) */
      color: white;
      border: none;
      border-radius: 6px; /* More squarish, similar to cards */
      text-transform: none; /* Normal casing, not uppercase */
      font-weight: bold; /* Make text bold like card values */
      letter-spacing: normal; /* Normal letter spacing */
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      display: flex; /* For centering text */
      align-items: center; /* For centering text */
      justify-content: center; /* For centering text */
      line-height: 1; /* Ensure text is vertically centered if it wraps (though it shouldn't) */
    }
    .btn-utility:hover {
      background-color: #95a5a6; /* Lighter grey on hover */
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
    }
    .card-value { /* This will be the main, large, centered number */
      font-size: 1.8em; /* Reduced for mobile */
      font-weight: 700;
      line-height: 1; /* Adjust line height for better centering */
      position: relative; /* Establish stacking context */
      z-index: 1; /* Ensure it's above the ::before pseudo-element */
    }
    .empty-discard-text {
      font-size: 0.9em; /* Smaller font for "Discard" text */
      line-height: normal; /* Ensure proper vertical alignment */
      color: #000 !important; /* Ensure text is black */
      /* Centering text if needed, though card itself is flex centered */
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%; /* Fill parent card height */
    }
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: #2c3e50;
      color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .notification.show {
      opacity: 1;
    }
    .history-log {
      height: 80px; /* Reduced height */
      overflow-y: auto;
      background-color: white;
      padding: 8px; /* Reduced padding */
      border-radius: 5px;
      margin-bottom: 10px; /* Reduced margin */
      font-size: 12px; /* Reduced font size */
    }
    .history-log p {
      margin: 3px 0; /* Reduced margin */
    }
    .server-info {
      text-align: center;
      margin-top: 10px; /* Reduced margin */
      padding: 8px; /* Reduced padding */
      background-color: #f8f9fa;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="setup-screen" class="setup-screen">
    <h1>Lost Cities</h1>
    <p>Play Lost Cities with your partner on your local network</p>
    
    <div class="input-group">
      <label for="playerName">Your Name:</label>
      <input type="text" id="playerName" placeholder="Enter your name">
    </div>
    
    <div class="input-group">
      <label for="serverAddress">Server Address:</label>
      <input type="text" id="serverAddress" placeholder="Enter server address (e.g., http://192.168.1.100:3000)">
    </div>
    
    <div class="input-group">
      <button id="createGame" class="btn">Create Game</button>
      <button id="joinGame" class="btn">Join Game</button>
    </div>
  </div>

  <div id="game-container" class="container" style="display: none;">
    <div class="title-row">
      <h1>Lost Cities</h1>
      <button id="toggle-log-btn" class="btn btn-utility">LOG</button>
    </div>
    <div id="game-status" class="game-status">Waiting for opponent...</div>
    

    <div class="history-log" id="history-log" style="display: none;">
      <p>Game started. Waiting for players...</p>
    </div>
    
    <div class="score-and-deck-row">
      <div id="opponent-score" class="score-card">
        <h3 id="opponent-name">Opponent: 0</h3>
        <p>Score: <span id="opponent-score-value">0</span></p>
      </div>
      <div class="deck" id="deck">
        <div class="card back">
          <div class="card-value">LC</div>
        </div>
        <div class="deck-count" id="deck-count">60</div>
      </div>
      <div id="player-info-in-deck-area" class="score-card">
        <h3 id="player-name-in-deck-area">You</h3>
        <p>Score: <span id="player-score-value-in-deck-area">0</span></p>
      </div>
    </div>
    
    <div class="board">
      <div id="game-columns-container">
        <!-- Color columns will be dynamically generated here by JavaScript -->
      </div>
    </div>
      
    <div id="player-action-row">
      <div class="hand" id="player-hand">
          <!-- Player's hand will be rendered here -->
      </div>
    </div>
    
    <div id="action-buttons-area" class="action-buttons-row">
      <div class="controls">
        <button id="play-card" class="btn">Play Card</button>
        <button id="discard-card" class="btn">Discard Card</button>
        <button id="draw-deck" class="btn">Draw from Deck</button>
        <div id="draw-discard-buttons-container"></div>
      </div>
    </div>

  </div>

  <div id="notification" class="notification"></div>

  <script>
    // Game state
    let gameState = {
      gameId: null, // Added to store gameId locally
      playerId: null, // This will store the persistentPlayerId
      playerName: '',
      opponentName: '',
      currentTurn: null, // This will be a persistentPlayerId
      selectedCard: null,
      selectedTarget: null,
      gamePhase: 'waiting', // waiting, selectCard, selectTarget, drawCard, gameOver
      hand: [],
      playerExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      opponentExpeditions: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      discardPiles: {
        red: [],
        green: [],
        white: [],
        blue: [],
        yellow: []
      },
      deckCount: 60,
      playerScore: 0,
      opponentScore: 0,
      playerScoreDetails: { red: 0, green: 0, blue: 0, white: 0, yellow: 0 },
      opponentScoreDetails: { red: 0, green: 0, blue: 0, white: 0, yellow: 0 }
    };

    // Socket connection
    let socket;
    let audioContext; // For playing sounds
    
    // DOM Elements
    const setupScreen = document.getElementById('setup-screen');
    const gameContainer = document.getElementById('game-container');
    const gameStatus = document.getElementById('game-status');
    const playerNameInput = document.getElementById('playerName');
    const serverAddressInput = document.getElementById('serverAddress');
    const createGameBtn = document.getElementById('createGame');
    const joinGameBtn = document.getElementById('joinGame');
    const playerHandEl = document.getElementById('player-hand');
    const deckEl = document.getElementById('deck');
    const deckCountEl = document.getElementById('deck-count');
    const playCardBtn = document.getElementById('play-card');
    const discardCardBtn = document.getElementById('discard-card');
    const drawDeckBtn = document.getElementById('draw-deck');
    const drawDiscardButtonsContainerEl = document.getElementById('draw-discard-buttons-container');
    // opponentScoreEl and opponentNameEl are still valid as their IDs are in the moved score card
    const opponentScoreEl = document.getElementById('opponent-score-value'); 
    const opponentNameEl = document.getElementById('opponent-name');
    const notificationEl = document.getElementById('notification');
    const historyLogEl = document.getElementById('history-log');
    const playerNameInDeckAreaEl = document.getElementById('player-name-in-deck-area');
    const playerScoreValueInDeckAreaEl = document.getElementById('player-score-value-in-deck-area');
    const toggleLogBtnEl = document.getElementById('toggle-log-btn');

    // Show notification
    function showNotification(message) {
      notificationEl.textContent = message;
      notificationEl.classList.add('show');
      setTimeout(() => {
        notificationEl.classList.remove('show');
      }, 3000);
    }

    // Add message to history log
    function addToHistory(message) {
      const p = document.createElement('p');
      p.textContent = message;
      historyLogEl.appendChild(p);
      historyLogEl.scrollTop = historyLogEl.scrollHeight;
    }

    // Initialize the game UI
    function initializeGame() {
      setupScreen.style.display = 'none';
      // gameContainer.style.display = 'block'; // Replaced by flex display
      gameContainer.style.display = 'flex';
      gameContainer.style.flexDirection = 'column';
      gameContainer.style.minHeight = '90vh'; // Encourage game container to be tall
      
      createBoardLayout(); // New function to create the column-based layout
      renderDiscardPiles(); // Render initial state of discard piles
    }

    // Render the game state
    function createBoardLayout() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      const gameColumnsContainer = document.getElementById('game-columns-container');
      gameColumnsContainer.innerHTML = ''; // Clear previous layout

      colors.forEach(color => {
        const columnEl = document.createElement('div');
        columnEl.className = 'color-column theme-' + color; // Apply theme class

        // 1. Opponent's Expedition Area
        const opponentExpeditionContainer = document.createElement('div');
        opponentExpeditionContainer.className = 'expedition card-expedition-area'; 
        
        const opponentLabel = document.createElement('div');
        opponentLabel.className = 'expedition-label';
        
        const opponentCardsEl = document.createElement('div');
        opponentCardsEl.className = 'expedition-cards';
        opponentCardsEl.id = `opponent-${color}-expedition`;
        
        opponentExpeditionContainer.appendChild(opponentLabel);
        opponentExpeditionContainer.appendChild(opponentCardsEl);
        columnEl.appendChild(opponentExpeditionContainer);

        // Opponent's score for this color (Above Discard)
        const opponentColorScoreEl = document.createElement('div');
        opponentColorScoreEl.id = `opponent-${color}-score-display`;
        opponentColorScoreEl.className = 'column-color-score';
        opponentColorScoreEl.textContent = '0'; // Default text
        columnEl.appendChild(opponentColorScoreEl);

        // 2. Discard Pile Area
        const discardPileContainer = document.createElement('div');
        discardPileContainer.className = 'expedition'; 
        
        const discardCardEl = document.createElement('div');
        discardCardEl.className = 'card'; 
        discardCardEl.classList.add(color); 
        discardCardEl.id = `discard-${color}`;
        discardCardEl.dataset.color = color;
        // The content of discardCardEl (empty state or top card) is handled by renderDiscardPiles
        discardCardEl.addEventListener('click', () => selectDiscardTarget(color));

        discardPileContainer.appendChild(discardCardEl);
        columnEl.appendChild(discardPileContainer);

        // Player's score for this color (Below Discard)
        const playerColorScoreEl = document.createElement('div');
        playerColorScoreEl.id = `player-${color}-score-display`;
        playerColorScoreEl.className = 'column-color-score';
        playerColorScoreEl.textContent = '0'; // Default text
        columnEl.appendChild(playerColorScoreEl);

        // 3. Player's Expedition Area
        const playerExpeditionContainer = document.createElement('div');
        playerExpeditionContainer.className = 'expedition card-expedition-area'; 
        
        const playerLabel = document.createElement('div');
        playerLabel.className = 'expedition-label';

        const playerCardsEl = document.createElement('div');
        playerCardsEl.className = 'expedition-cards';
        playerCardsEl.id = `player-${color}-expedition`;
        playerCardsEl.dataset.color = color;
        playerCardsEl.addEventListener('click', () => selectExpeditionTarget(color));

        playerExpeditionContainer.appendChild(playerLabel);
        playerExpeditionContainer.appendChild(playerCardsEl);
        columnEl.appendChild(playerExpeditionContainer);

        gameColumnsContainer.appendChild(columnEl);
      });
      
      // Ensure deck click listener is active (it should be fine as deckEl is static HTML)
      // If deckEl was dynamically created, you'd add listener here.
      // deckEl.addEventListener('click', () => drawFromDeck()); // Already added globally
    }

    function renderGameState() {
      renderHand();
      renderExpeditions();
      renderDiscardPiles();
      updateDeckCount();
      updateScores();
      updateGameStatus();
      updateControls();
      adjustLayoutForScreenSize(); // New function to handle responsive layout
    }

    function renderHand() {
      playerHandEl.innerHTML = '';
      
      gameState.hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        cardEl.className = 'card';
        // cardEl.classList.add(card.color); // Color class for text, background set directly
        if (card.color === 'white' || card.color === 'yellow') {
          cardEl.classList.add(card.color); // Add class for light background text color rule
        }
        cardEl.classList.add('theme-' + card.color); // Add theme class for pattern
        cardEl.style.backgroundColor = getColorCode(card.color); // Apply background color
        cardEl.dataset.index = index;
        cardEl.dataset.color = card.color;
        cardEl.dataset.value = card.value;
        
        const cardContent = card.value === 0 ? 'ðŸ’°' : card.value;

        const valueCenterEl = document.createElement('div');
        valueCenterEl.className = 'card-value';
        valueCenterEl.textContent = cardContent;
        if (card.value === 6 || card.value === 9) {
          valueCenterEl.style.textDecoration = 'underline';
        }
        
        cardEl.appendChild(valueCenterEl);
        
        if (gameState.selectedCard === index) {
          cardEl.style.border = '3px solid black';
        }
        
        cardEl.addEventListener('click', () => selectCard(index));
        playerHandEl.appendChild(cardEl);
      });
    }

    function renderExpeditions() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const playerExpEl = document.getElementById(`player-${color}-expedition`);
        const opponentExpEl = document.getElementById(`opponent-${color}-expedition`);
        
        // Clear existing cards
        playerExpEl.innerHTML = '';
        opponentExpEl.innerHTML = '';
        
        // Render player expedition
        const playerColumnEl = playerExpEl.closest('.color-column');
        const playerColumnWidth = playerColumnEl ? playerColumnEl.offsetWidth : 60; // Fallback to min-width

        gameState.playerExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          // cardEl.classList.add(color); // Background set directly
          if (card.color === 'white' || card.color === 'yellow') {
            cardEl.classList.add(card.color); // Add class for light background text color rule
          }
          cardEl.classList.add('theme-' + card.color); // Add theme class for pattern
          cardEl.style.backgroundColor = getColorCode(color);

          const defaultCardWidth = 40; // From .card CSS
          const defaultCardHeight = 45; // From .card CSS
          const originalVerticalStep = 28;
          
          const expeditionCardMaxWidth = playerColumnWidth / 3;
          const targetWidth = Math.max(10, Math.min(expeditionCardMaxWidth, defaultCardWidth)); // Ensure a minimum width
          const targetHeight = targetWidth * (defaultCardHeight / defaultCardWidth);

          cardEl.style.width = targetWidth + 'px';
          cardEl.style.height = targetHeight + 'px';
          // Scale font size proportionally. 1em in .card-value will be relative to this.
          // If targetWidth is half of default, font-size becomes 50%.
          cardEl.style.fontSize = (targetWidth / defaultCardWidth) * 100 + '%';
          
          const cardContent = card.value === 0 ? 'ðŸ’°' : card.value;

          const valueCenterEl = document.createElement('div');
          valueCenterEl.className = 'card-value';
          valueCenterEl.textContent = cardContent;
          if (card.value === 6 || card.value === 9) {
            valueCenterEl.style.textDecoration = 'underline';
          }
          
          cardEl.appendChild(valueCenterEl);

          cardEl.style.position = 'absolute';
          const playerCardIndex = playerExpEl.childNodes.length; // Index before appending
          // Adjust vertical step proportionally to new card height
          const verticalStepFactor = originalVerticalStep / defaultCardHeight;
          const verticalOffsetPlayer = playerCardIndex * (targetHeight * verticalStepFactor);
          
          // Determine horizontal offset based on card index for left-middle-right-middle pattern
          let horizontalOffsetPlayer;
          const playerPosIndex = playerCardIndex % 4;
          const baseOffset1Player = Math.round(playerColumnWidth / 3);
          const baseOffset2Player = Math.round(playerColumnWidth * 2 / 3);
          if (playerPosIndex === 0) { // 1st, 5th, etc. card: Left
            horizontalOffsetPlayer = '-8px'; // Shifted left to reduce gap from column edge
          } else if (playerPosIndex === 1) { // 2nd, 6th, etc. card: Middle
            horizontalOffsetPlayer = (baseOffset1Player - 8) + 'px';
          } else if (playerPosIndex === 2) { // 3rd, 7th, etc. card: Right
            horizontalOffsetPlayer = (baseOffset2Player - 8) + 'px';
          } else { // playerPosIndex === 3, 4th, 8th, etc. card: Middle
            horizontalOffsetPlayer = (baseOffset1Player - 8) + 'px';
          }
          
          cardEl.style.left = horizontalOffsetPlayer;
          cardEl.style.bottom = verticalOffsetPlayer + 'px';
          cardEl.style.zIndex = playerCardIndex;
          
          playerExpEl.appendChild(cardEl);
        });
        
        // Render opponent expedition
        const opponentColumnEl = opponentExpEl.closest('.color-column');
        const opponentColumnWidth = opponentColumnEl ? opponentColumnEl.offsetWidth : 60; // Fallback to min-width

        gameState.opponentExpeditions[color].forEach(card => {
          const cardEl = document.createElement('div');
          cardEl.className = 'card';
          // cardEl.classList.add(color); // Background set directly
          if (card.color === 'white' || card.color === 'yellow') {
            cardEl.classList.add(card.color); // Add class for light background text color rule
          }
          cardEl.classList.add('theme-' + card.color); // Add theme class for pattern
          cardEl.style.backgroundColor = getColorCode(color);

          const defaultCardWidth = 40; // From .card CSS
          const defaultCardHeight = 45; // From .card CSS
          const originalVerticalStep = 28;

          const expeditionCardMaxWidth = opponentColumnWidth / 3;
          const targetWidth = Math.max(10, Math.min(expeditionCardMaxWidth, defaultCardWidth)); // Ensure a minimum width
          const targetHeight = targetWidth * (defaultCardHeight / defaultCardWidth);

          cardEl.style.width = targetWidth + 'px';
          cardEl.style.height = targetHeight + 'px';
          // Scale font size proportionally
          cardEl.style.fontSize = (targetWidth / defaultCardWidth) * 100 + '%';

          const cardContent = card.value === 0 ? 'ðŸ’°' : card.value;

          const valueCenterEl = document.createElement('div');
          valueCenterEl.className = 'card-value';
          valueCenterEl.textContent = cardContent;
          if (card.value === 6 || card.value === 9) {
            valueCenterEl.style.textDecoration = 'underline';
          }
          
          cardEl.appendChild(valueCenterEl);

          cardEl.style.position = 'absolute';
          const opponentCardIndex = opponentExpEl.childNodes.length; // Index before appending
          // Adjust vertical step proportionally to new card height
          const verticalStepFactor = originalVerticalStep / defaultCardHeight;
          const verticalOffsetOpponent = opponentCardIndex * (targetHeight * verticalStepFactor);
          
          // Determine horizontal offset based on card index for left-middle-right-middle pattern
          let horizontalOffsetOpponent;
          const opponentPosIndex = opponentCardIndex % 4;
          const baseOffset1Opponent = Math.round(opponentColumnWidth / 3);
          const baseOffset2Opponent = Math.round(opponentColumnWidth * 2 / 3);
          if (opponentPosIndex === 0) { // 1st, 5th, etc. card: Left
            horizontalOffsetOpponent = '-8px'; // Shifted left to reduce gap from column edge
          } else if (opponentPosIndex === 1) { // 2nd, 6th, etc. card: Middle
            horizontalOffsetOpponent = (baseOffset1Opponent - 8) + 'px';
          } else if (opponentPosIndex === 2) { // 3rd, 7th, etc. card: Right
            horizontalOffsetOpponent = (baseOffset2Opponent - 8) + 'px';
          } else { // opponentPosIndex === 3, 4th, 8th, etc. card: Middle
            horizontalOffsetOpponent = (baseOffset1Opponent - 8) + 'px';
          }
          
          cardEl.style.left = horizontalOffsetOpponent;
          cardEl.style.top = verticalOffsetOpponent + 'px';
          cardEl.style.zIndex = opponentCardIndex;

          opponentExpEl.appendChild(cardEl);
        });
        
        // Add highlight if selected as target
        if (gameState.selectedTarget === `expedition-${color}`) {
          playerExpEl.style.border = '3px solid black';
        } else {
          playerExpEl.style.border = 'none';
        }
      });
    }

    function renderDiscardPiles() {
      const colors = ['red', 'green', 'blue', 'white', 'yellow'];
      
      colors.forEach(color => {
        const discardEl = document.getElementById(`discard-${color}`);
        const discardPile = gameState.discardPiles[color];
        const colorsForThemes = ['red', 'green', 'blue', 'white', 'yellow'];

        // Clear any existing theme classes first
        colorsForThemes.forEach(c => discardEl.classList.remove('theme-' + c));
        
        if (discardPile.length > 0) {
          const topCard = discardPile[discardPile.length - 1];
          discardEl.classList.add('theme-' + topCard.color); // Add theme class for pattern
          discardEl.style.backgroundColor = getColorCode(topCard.color);
          if (topCard.color === 'white' || topCard.color === 'yellow') {
            discardEl.style.color = '#333';
          } else {
            discardEl.style.color = '#fff';
          }
          
          const cardContent = topCard.value === 0 ? 'ðŸ’°' : topCard.value;
          const underlineStyle = (topCard.value === 6 || topCard.value === 9) ? 'text-decoration: underline;' : '';
          discardEl.innerHTML = `
            <div class="card-value" style="${underlineStyle}">${cardContent}</div>
          `;
          // Reset box-shadow and border to card defaults if a card is present
          discardEl.style.boxShadow = ''; // Will revert to CSS rule for .card
          // discardEl.style.border = ''; // Border is handled by selection logic below
        } else {
          discardEl.style.backgroundColor = '#E9E9E9'; // Light grey background for empty pile
          discardEl.style.color = '#000 !important'; // Set text color on the card placeholder itself to black
          discardEl.innerHTML = '<div class="empty-discard-text">Discard</div>'; 
          discardEl.style.boxShadow = 'inset 0px 1px 4px rgba(0, 0, 0, 0.2)'; // Subtle inset shadow
          discardEl.style.border = '1px dashed #777'; // Dashed border for empty state
        }
        
        // Add highlight if selected as target
        // Reset border first, then apply if selected.
        // The border style for empty discard piles is now set above.
        // The default card border is handled by the .card class.
        // So, we only need to handle the 'selected' black border.
        if (gameState.selectedTarget === `discard-${color}`) {
          discardEl.style.border = '3px solid black';
        } else {
          // If not selected, and it's an empty pile, it keeps its dashed border.
          // If not selected, and it's a card, it keeps its default .card border.
          // So, if it's NOT empty and NOT selected, we ensure it has the default card border.
          if (discardPile.length > 0) { // If it has a card
             discardEl.style.border = '1px solid #333'; // Default card border
          }
          // If it's empty, the dashed border from above applies.
        }
      });
    }

    function updateDeckCount() {
      deckCountEl.textContent = gameState.deckCount;
    }

    function updateScores() {
      if (playerNameInDeckAreaEl) playerNameInDeckAreaEl.textContent = gameState.playerName || 'You';
      if (playerScoreValueInDeckAreaEl) playerScoreValueInDeckAreaEl.textContent = gameState.playerScore;
      
      if (opponentNameEl) opponentNameEl.textContent = `${gameState.opponentName || 'Opponent'}`;
      if (opponentScoreEl) opponentScoreEl.textContent = gameState.opponentScore;

      const colors = ['red', 'green', 'blue', 'white', 'yellow'];

      colors.forEach(color => {
        // Update player's color score in the column
        const playerColorScoreDisplayEl = document.getElementById(`player-${color}-score-display`);
        if (playerColorScoreDisplayEl && gameState.playerScoreDetails) {
          playerColorScoreDisplayEl.textContent = `${gameState.playerScoreDetails[color] || 0}`;
        }

        // Update opponent's color score in the column
        const opponentColorScoreDisplayEl = document.getElementById(`opponent-${color}-score-display`);
        if (opponentColorScoreDisplayEl && gameState.opponentScoreDetails) {
          opponentColorScoreDisplayEl.textContent = `${gameState.opponentScoreDetails[color] || 0}`;
        }
      });
    }

    function updateGameStatus() {
      const opponentScoreCard = document.getElementById('opponent-score');
      const playerScoreCard = document.getElementById('player-info-in-deck-area');
      
      opponentScoreCard.classList.remove('active');
      playerScoreCard.classList.remove('active');
      
      if (gameState.gamePhase === 'waiting') {
        gameStatus.textContent = 'Waiting for opponent...';
      } else if (gameState.gamePhase === 'gameOver') {
        gameStatus.textContent = 'Game Over!';
      } else if (gameState.currentTurn === gameState.playerId) {
        playerScoreCard.classList.add('active');
        
        if (gameState.gamePhase === 'selectCard') {
          if (gameState.selectedCard !== null) {
            if (gameState.selectedTarget && gameState.selectedTarget.startsWith('discard')) {
              gameStatus.textContent = 'Card and discard pile selected. Click "Discard Card".';
            } else {
              // If an expedition is selected, it's just for visual feedback or drawing, not for playing.
              gameStatus.textContent = 'Card selected. Click "Play Card" (plays to its color) or "Discard Card".';
            }
          } else {
            gameStatus.textContent = 'Your turn: Select a card to play or discard';
          }
        } else if (gameState.gamePhase === 'drawCard') {
          gameStatus.textContent = 'Draw a card from the deck or a discard pile';
        }
      } else {
        opponentScoreCard.classList.add('active');
        gameStatus.textContent = `${gameState.opponentName}'s turn`;
      }
    }

    function updateControls() {
      // Hide all buttons initially
      playCardBtn.style.display = 'none';
      discardCardBtn.style.display = 'none';
      drawDeckBtn.style.display = 'none';
      drawDiscardButtonsContainerEl.innerHTML = ''; // Clear dynamic buttons

      const isPlayerTurn = gameState.currentTurn === gameState.playerId;
      const cardSelected = gameState.selectedCard !== null;
      // targetSelected is used by updateGameStatus, so it's still relevant if calculated.
      // const targetSelected = gameState.selectedTarget !== null; 
      const isSelectCardPhase = gameState.gamePhase === 'selectCard';
      const isDrawCardPhase = gameState.gamePhase === 'drawCard';

      if (isPlayerTurn && isSelectCardPhase && cardSelected) {
        playCardBtn.style.display = 'inline-block';
        discardCardBtn.style.display = 'inline-block';
      }

      if (isPlayerTurn && isDrawCardPhase) {
        drawDeckBtn.style.display = 'inline-block';

        const colors = ['red', 'green', 'blue', 'white', 'yellow'];
        colors.forEach(color => {
          if (gameState.discardPiles[color] && gameState.discardPiles[color].length > 0) {
            // Server will validate if this specific card can be drawn (e.g. not just discarded by player)
            const btn = document.createElement('button');
            btn.className = 'btn'; // Assumes .btn class has appropriate display like inline-block
            btn.textContent = `Draw from ${capitalizeFirstLetter(color)} Discard`;
            btn.addEventListener('click', () => drawFromDiscard(color));
            drawDiscardButtonsContainerEl.appendChild(btn);
          }
        });
      }
    }

    // Game actions
    function selectCard(index) {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'selectCard') {
        return;
      }
      
      if (gameState.selectedCard === index) {
        gameState.selectedCard = null;
      } else {
        gameState.selectedCard = index;
      }
      
      renderGameState();
    }

    function selectExpeditionTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      if (gameState.selectedTarget === `expedition-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `expedition-${color}`;
      }
      
      renderGameState();
    }

    function selectDiscardTarget(color) {
      if (gameState.currentTurn !== gameState.playerId || 
          (gameState.gamePhase !== 'selectCard' && gameState.gamePhase !== 'drawCard')) {
        return;
      }
      
      // Can't draw from empty discard pile
      if (gameState.gamePhase === 'drawCard' && gameState.discardPiles[color].length === 0) {
        showNotification("Can't draw from an empty discard pile");
        console.log(`DEBUG: selectDiscardTarget - Attempted to select empty discard pile: ${color}`);
        return;
      }
      
      console.log(`DEBUG: selectDiscardTarget - Color: ${color}, Current Phase: ${gameState.gamePhase}, Pile content:`, JSON.stringify(gameState.discardPiles[color]));
      if (gameState.selectedTarget === `discard-${color}`) {
        gameState.selectedTarget = null;
      } else {
        gameState.selectedTarget = `discard-${color}`;
      }
      
      renderGameState();
    }

    function playCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      const targetColor = card.color; // Play to the card's own color expedition
      
      // Check if card can be played on this expedition (this check might seem redundant now, but good for safety)
      if (card.color !== targetColor) {
        showNotification(`Can only play ${card.color} cards on the ${card.color} expedition`);
        return;
      }
      
      // Check if card value is valid (must be ascending)
      const expedition = gameState.playerExpeditions[targetColor];
      if (expedition.length > 0) {
        const lastCardValue = expedition[expedition.length - 1].value;
        if (card.value <= lastCardValue && lastCardValue !== 0) {
          showNotification(`Card value must be higher than the last card (${lastCardValue})`);
          return;
        }
      }
      
      // Send play card action to server
      socket.emit('playCard', {
        cardIndex: gameState.selectedCard,
        target: targetColor
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function discardCard() {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'selectCard' ||
          gameState.selectedCard === null) {
        return;
      }
      
      const card = gameState.hand[gameState.selectedCard];
      // Target color for discarding is ALWAYS the card's own color.
      const targetColor = card.color; 
      
      // The gameState.selectedTarget (if it's a discard pile) is now only for UI feedback
      // or for the "Draw from Discard" action. It no longer dictates the discard color for this action.
      
      // Send discard card action to server
      socket.emit('discardCard', {
        cardIndex: gameState.selectedCard,
        color: targetColor // This will ensure the card is discarded to its own color pile
      });
      
      // Reset selection
      gameState.selectedCard = null;
      gameState.selectedTarget = null;
    }

    function drawFromDeck() {
      if (gameState.currentTurn !== gameState.playerId || gameState.gamePhase !== 'drawCard') {
        return;
      }
      
      // Send draw from deck action to server
      socket.emit('drawCard', { source: 'deck' });
      
      // Reset selection
      gameState.selectedTarget = null;
    }

    function drawFromDiscard(colorToDraw) {
      if (gameState.currentTurn !== gameState.playerId || 
          gameState.gamePhase !== 'drawCard') {
        // Basic phase/turn checks
        return;
      }
      
      // Check if discard pile has cards (this is also checked before creating the button, but good for safety)
      if (!gameState.discardPiles[colorToDraw] || gameState.discardPiles[colorToDraw].length === 0) {
        showNotification(`Discard pile for ${colorToDraw} is empty or invalid.`);
        return;
      }
      
      // Server will handle the "can't draw what you just discarded" rule.
      
      // Send draw from discard action to server
      socket.emit('drawCard', { source: 'discard', color: colorToDraw });
      
      // Reset visual selection if any, especially if the clicked discard pile was selected
      if (gameState.selectedTarget && gameState.selectedTarget === `discard-${colorToDraw}`) {
        gameState.selectedTarget = null;
      }
      // No need to call renderGameState() here, server response will trigger it.
    }

    // Helper functions
    function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

    function getColorCode(color) {
      const colorCodes = {
        red: '#EF5350',     // A softer, modern Red
        green: '#66BB6A',   // A softer, modern Green
        blue: '#42A5F5',    // A softer, modern Blue
        white: '#BDBDBD',   // A light, neutral Grey for "white"
        yellow: '#FFEE58'   // A vibrant, modern Yellow
      };
      return colorCodes[color] || '#9E9E9E'; // Default to a mid-grey
    }

    // Socket event handlers
    function setupSocketEvents() {
      socket.on('connect', () => {
        console.log('Connected to server');
        // No automatic reconnection attempt on connect anymore
      });
      
      socket.on('gameState', (state) => {
        // Update game state by merging new state from server.
        // Properties like playerScore, playerScoreDetails, opponentScore, and opponentScoreDetails
        // will be directly updated from the 'state' object if provided by the server.
        gameState = { ...gameState, ...state };

        // Ensure details objects are initialized if not provided (should be by server now)
        gameState.playerScoreDetails = gameState.playerScoreDetails || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        gameState.opponentScoreDetails = gameState.opponentScoreDetails || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        
        console.log(`DEBUG: socket.on('gameState') - Received gamePhase: ${state.gamePhase}, currentTurn: ${state.currentTurn}, client's playerId: ${gameState.playerId}`);
        console.log('DEBUG: Updated playerScoreDetails:', gameState.playerScoreDetails);
        console.log('DEBUG: Updated opponentScoreDetails:', gameState.opponentScoreDetails);
        renderGameState();
      });
      
      socket.on('playerJoined', (data) => {
        // data.playerId is persistentPlayerId
        if (data.playerId !== gameState.playerId) {
          gameState.opponentName = data.playerName;
          addToHistory(`${data.playerName} joined the game`);
        }
        renderGameState(); // Opponent name might have changed
      });
      
      socket.on('gameStarted', (data) => {
        // data.currentTurn is persistentPlayerId
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = 'selectCard';
        addToHistory('Game started!');
        renderGameState();
      });
      
      socket.on('turnChanged', (data) => {
        // data.currentTurn is persistentPlayerId
        const previousTurn = gameState.currentTurn; // Capture current turn *before* updating it
        gameState.currentTurn = data.currentTurn;
        gameState.gamePhase = data.gamePhase;
        
        if (gameState.currentTurn === gameState.playerId) {
          // Play sound only if the turn has *changed* to this player,
          // and it wasn't null before (i.e., not the very first turn of the game setup)
          if (previousTurn !== gameState.playerId && previousTurn !== null) { 
            playTurnSound();
          }
          addToHistory('Your turn');
        } else {
          addToHistory(`${gameState.opponentName}'s turn`);
        }
        renderGameState();
      });
      
      socket.on('cardPlayed', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} played a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDiscarded', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        addToHistory(`${playerNameDisplay} discarded a ${data.card.value === 0 ? 'wager' : data.card.value} ${data.card.color} card`);
      });
      
      socket.on('cardDrawn', (data) => {
        // data.playerId is persistentPlayerId
        const playerNameDisplay = data.playerId === gameState.playerId ? 'You' : (gameState.opponentName || 'Opponent');
        const source = data.source === 'deck' ? 'the deck' : `the ${data.color} discard pile`;
        addToHistory(`${playerNameDisplay} drew a card from ${source}`);
      });

      socket.on('opponentDisconnected', (data) => {
        showNotification(data.message);
        addToHistory(data.message);
        // Transition to a state where the user must start/join a new game
        gameStatus.textContent = data.message + " Please start or join a new game.";
        // Disable game controls, effectively ending the game on the client side
        playCardBtn.disabled = true;
        discardCardBtn.disabled = true;
        drawDeckBtn.disabled = true;
        drawDiscardBtn.disabled = true;
        // Optionally, redirect to setup screen or show a "New Game" button
        // For now, just update status and disable buttons.
        // Consider clearing gameId to prevent accidental reuse if not starting fresh
        gameState.gameId = null; 
      });
      
      socket.on('gameOver', (data) => {
        // data.scores keys are persistentPlayerIds
        gameState.gamePhase = 'gameOver';
        if (data.scores && gameState.playerId && data.scores[gameState.playerId]) {
            gameState.playerScore = data.scores[gameState.playerId].total || 0;
            gameState.playerScoreDetails = data.scores[gameState.playerId].details || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        }
        
        const opponentPersistentId = Object.keys(data.scores || {}).find(id => id !== gameState.playerId);
        if (opponentPersistentId && data.scores && data.scores[opponentPersistentId]) {
          gameState.opponentScore = data.scores[opponentPersistentId].total || 0;
          gameState.opponentScoreDetails = data.scores[opponentPersistentId].details || { red: 0, green: 0, blue: 0, white: 0, yellow: 0 };
        }
        
        let message = 'Game over! ';
        if (gameState.playerScore > gameState.opponentScore) {
          message += 'You win!';
        } else if (gameState.playerScore < gameState.opponentScore) {
          message += `${gameState.opponentName || 'Opponent'} wins!`;
        } else {
          message += "It's a tie!";
        }
        
        addToHistory(message);
        showNotification(message);
        renderGameState();

        // Clear stored game data as game is over
        localStorage.removeItem('lostCitiesGameId');
        localStorage.removeItem('lostCitiesPlayerId');
        localStorage.removeItem('lostCitiesPlayerName');
        gameState.gameId = null; 
        // gameState.playerId = null; // Keep playerId for score display until new game
      });
      
      socket.on('error', (error) => {
        showNotification(`Error: ${error.message}`);
        // Removed reconnection-specific error handling
      });
      
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        showNotification('Disconnected from server. Please start or join a new game.');
        // Transition to a state where the user must start/join a new game
        setupScreen.style.display = 'block';
        gameContainer.style.display = 'none';
        gameStatus.textContent = 'Disconnected. Please start or join a new game.';
        // Clear any potentially stale game state
        gameState.gameId = null;
        gameState.playerId = null;
      });
    }

    function connectToServer(serverAddress, isCreatingGame, isJoiningGame) {
      try {
        if (!audioContext) { // Initialize AudioContext on first user gesture
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (socket && socket.connected) {
            socket.disconnect(); // Disconnect existing socket if any before creating new
        }
        socket = io(serverAddress, {
            reconnection: false // Disable automatic reconnection
        });
        gameState.playerName = playerNameInput.value.trim() || localStorage.getItem('lostCitiesPlayerName') || (isCreatingGame ? 'Player 1' : 'Player 2');
        localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Store/update name

        setupSocketEvents(); // Setup handlers for the new socket instance
        
        if (isCreatingGame) {
          socket.emit('createGame', { playerName: gameState.playerName });
        } else if (isJoiningGame) {
          socket.emit('joinGame', { playerName: gameState.playerName });
        }
        // No third case for reconnection attempts
      } catch (error) {
        alert(`Error connecting to server: ${error.message}`);
      }
    }

    // Create game button click handler
    createGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, true, false);
    });


    // Join game button click handler
    joinGameBtn.addEventListener('click', () => {
      // No longer need to clear gameId/playerId from localStorage for reconnection purposes
      const serverAddress = serverAddressInput.value.trim() || 'http://localhost:3000';
      connectToServer(serverAddress, false, true);
    });

    // Modify setupSocketEvents to remove localStorage setting for gameId/playerId
    const originalSetupSocketEvents = setupSocketEvents;
    setupSocketEvents = () => {
      originalSetupSocketEvents(); // Call original events

      if (socket) { // Ensure socket exists before adding new listeners
        socket.on('gameCreated', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory('Game created. Waiting for opponent...');
          showNotification('Game created! Waiting for opponent to join...');
        });

        socket.on('gameJoined', (data) => {
          gameState.playerId = data.playerId; // persistentPlayerId
          gameState.gameId = data.gameId;
          gameState.opponentName = data.hostName;
          localStorage.setItem('lostCitiesPlayerName', gameState.playerName); // Keep for convenience
          initializeGame();
          addToHistory(`Joined game hosted by ${data.hostName}`);
          showNotification(`Joined game! Playing against ${data.hostName}`);
        });
      }
    };


    // Play card button click handler
    playCardBtn.addEventListener('click', playCard);
    
    // Discard card button click handler
    discardCardBtn.addEventListener('click', discardCard);
    
    // Draw deck button click handler
    drawDeckBtn.addEventListener('click', drawFromDeck);
    
    // Draw discard button click handler (old generic button's listener is removed as button is removed)

    // Toggle Log button click handler
    if (toggleLogBtnEl) {
      toggleLogBtnEl.addEventListener('click', () => {
        if (historyLogEl.style.display === 'none') {
          historyLogEl.style.display = 'block';
        } else {
          historyLogEl.style.display = 'none';
        }
      });
    }

    // Initial page load logic
    document.addEventListener('DOMContentLoaded', () => {
      // Load only player name and server address from localStorage
      const storedPlayerName = localStorage.getItem('lostCitiesPlayerName');
      const serverAddress = localStorage.getItem('lostCitiesServerAddress') || 'http://192.168.1.114:3000';

      playerNameInput.value = storedPlayerName || '';
      serverAddressInput.value = serverAddress;

      // Always show setup screen on load, no automatic reconnection
      setupScreen.style.display = 'block';
      gameContainer.style.display = 'none';

      // Save server address when it changes
      serverAddressInput.addEventListener('change', () => {
        localStorage.setItem('lostCitiesServerAddress', serverAddressInput.value.trim());
      });
    });

    // Function to adjust layout based on screen size
    function adjustLayoutForScreenSize() {
      const isMobile = window.innerWidth < 768;
      const gameColumnsContainer = document.getElementById('game-columns-container');
      const scoreAndDeckRow = document.querySelector('.score-and-deck-row');
      
      if (isMobile) {
        // Mobile layout adjustments
        gameColumnsContainer.style.width = '100%';
        scoreAndDeckRow.style.gap = '5px'; // Smaller gap for mobile
        
        // Make score cards smaller on mobile
        document.querySelectorAll('.score-and-deck-row .score-card').forEach(card => {
          card.style.width = 'auto';
          card.style.maxWidth = '30%';
          card.style.padding = '8px';
          card.style.fontSize = '0.9em';
        });
        
        // Make deck smaller on mobile
        const deckElement = document.querySelector('.score-and-deck-row .deck');
        if (deckElement) {
          deckElement.style.margin = '0 5px';
        }
        
        // Adjust card positioning for smaller screens
        document.querySelectorAll('.expedition-cards .card').forEach(card => {
          const currentBottom = parseInt(card.style.bottom || '0');
          const currentTop = parseInt(card.style.top || '0');
          
          if (card.style.bottom) {
            card.style.bottom = (currentBottom * 0.7) + 'px'; // Scale down vertical spacing
          }
          if (card.style.top) {
            card.style.top = (currentTop * 0.7) + 'px'; // Scale down vertical spacing
          }
          
          // Adjust horizontal positioning
          if (card.style.left) {
            const currentLeft = parseInt(card.style.left);
            card.style.left = Math.min(currentLeft, 80) + 'px'; // Limit maximum left position
          }
        });
      } else {
        // Desktop layout adjustments
        gameColumnsContainer.style.width = '';
        scoreAndDeckRow.style.gap = '';
        
        // Reset score card width for desktop
        document.querySelectorAll('.score-and-deck-row .score-card').forEach(card => {
          card.style.width = 'auto';
          card.style.maxWidth = '200px';
          card.style.padding = '15px 30px';
          card.style.fontSize = '';
        });
        
        // Reset deck margins for desktop
        const deckElement = document.querySelector('.score-and-deck-row .deck');
        if (deckElement) {
          deckElement.style.margin = '';
        }
      }
    }

    // Add window resize listener
    window.addEventListener('resize', adjustLayoutForScreenSize);

    // Function to play a turn notification sound
    function playTurnSound() {
      if (!audioContext || audioContext.state === 'suspended') {
        audioContext.resume(); // Attempt to resume if suspended
      }
      if (!audioContext || audioContext.state !== 'running') {
        console.warn('AudioContext not running, cannot play sound.');
        return;
      }

      const now = audioContext.currentTime;
      const fundamentalHz = 523.25; // C5 note

      // Frequencies for the bell sound (fundamental, a fifth, an octave)
      const frequencies = [
        fundamentalHz,
        fundamentalHz * 1.5,
        fundamentalHz * 2.0
      ];

      // Gain values for each partial (fundamental is loudest)
      const initialGains = [0.15, 0.105, 0.075]; 
      // Decay times for each partial (overtones decay slightly faster)
      const decayTimes = [1.0, 0.8, 0.6];

      frequencies.forEach((freq, index) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();

        osc.connect(gain);
        gain.connect(audioContext.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);

        // Set initial gain with a very quick attack
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(initialGains[index], now + 0.01);
        
        // Exponential decay
        gain.gain.exponentialRampToValueAtTime(0.0001, now + decayTimes[index]);

        osc.start(now);
        osc.stop(now + decayTimes[index] + 0.1); // Stop oscillator shortly after gain is negligible
      });
    }
  </script>
</body>
</html>
